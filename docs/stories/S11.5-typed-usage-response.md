# Story: Typed Usage Response Structs

**Story ID:** S11.5 **Epic:**
[E011 - Claude Usage Crate](../epic/E011-claude-usage-crate.md) **Status:**
Draft **Priority:** P0 **Estimated Points:** 2

## Description

As a developer, I want the claude-usage crate to return typed, structured usage
data, So that I can work with strongly-typed data instead of parsing JSON
manually.

## Context

The Anthropic usage API returns a JSON response with utilization percentages and
reset times. This story defines Rust structs that map to this response and
provides the main public API: `get_usage() -> Result<UsageData>`.

## Implementation Details

### Technical Approach

1. Define structs matching the API response shape
2. Use serde for deserialization
3. Provide helper methods for common operations
4. Combine credential fetch + API call into single `get_usage()` function
5. Export types as part of public API

### API Response Shape

```json
{
  "five_hour": { "utilization": 8.0, "resets_at": "2026-01-22T09:00:00Z" },
  "seven_day": { "utilization": 77.0, "resets_at": "2026-01-22T19:00:00Z" },
  "seven_day_sonnet": { "utilization": 0.0, "resets_at": "..." },
  "extra_usage": { "is_enabled": false, ... }
}
```

### Files to Create/Modify

- `crates/claude-usage/src/types.rs` - Type definitions
- `crates/claude-usage/src/lib.rs` - Main `get_usage()` function and exports

### Dependencies

- [S11.4 - Usage API Client](./S11.4-usage-api-client.md)

## Acceptance Criteria

- [ ] Given valid API response, when parsed, then all fields are correctly
      populated
- [ ] Given missing optional fields, when parsed, then defaults are used
- [ ] Given `get_usage()` call, when successful, then `UsageData` is returned
- [ ] Given any error in the chain, when `get_usage()` fails, then unified
      `Error` type is returned
- [ ] Given `UsageData`, when helper methods called, then useful derived values
      are computed

## Testing Requirements

- [ ] Unit test: Parse sample API response correctly
- [ ] Unit test: Handle missing fields gracefully
- [ ] Unit test: Helper methods compute correct values
- [ ] Unit test: Serialization round-trip preserves data

## Out of Scope

- Caching of responses
- Historical data tracking
- Comparison between time periods

## Notes

### Type Definitions

```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Main usage data returned by `get_usage()`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsageData {
    pub five_hour: UsagePeriod,
    pub seven_day: UsagePeriod,
    #[serde(default)]
    pub seven_day_sonnet: Option<UsagePeriod>,
    #[serde(default)]
    pub extra_usage: Option<ExtraUsage>,
}

/// Usage data for a specific time period
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsagePeriod {
    /// Percentage of quota used (0.0 - 100.0+)
    pub utilization: f64,
    /// When this period resets
    pub resets_at: DateTime<Utc>,
}

/// Extra usage billing information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtraUsage {
    pub is_enabled: bool,
    #[serde(default)]
    pub amount_used: Option<f64>,
    #[serde(default)]
    pub limit: Option<f64>,
}
```

### Helper Methods

```rust
impl UsagePeriod {
    /// Time remaining until reset
    pub fn time_until_reset(&self) -> chrono::Duration {
        self.resets_at - Utc::now()
    }

    /// Percentage of time period elapsed
    pub fn time_elapsed_percent(&self, period_hours: u32) -> f64 {
        let total_seconds = period_hours as f64 * 3600.0;
        let remaining_seconds = self.time_until_reset().num_seconds() as f64;
        let elapsed_seconds = total_seconds - remaining_seconds;
        (elapsed_seconds / total_seconds * 100.0).clamp(0.0, 100.0)
    }

    /// Whether usage is on pace (utilization <= time elapsed)
    pub fn is_on_pace(&self, period_hours: u32) -> bool {
        self.utilization <= self.time_elapsed_percent(period_hours)
    }
}

impl UsageData {
    /// Whether 5-hour usage is on pace
    pub fn five_hour_on_pace(&self) -> bool {
        self.five_hour.is_on_pace(5)
    }

    /// Whether 7-day usage is on pace
    pub fn seven_day_on_pace(&self) -> bool {
        self.seven_day.is_on_pace(7 * 24)
    }
}
```

### Main Public API

```rust
// In lib.rs

/// Fetch current Claude API usage data
///
/// This is the main entry point. It:
/// 1. Retrieves credentials from platform-specific storage
/// 2. Calls the Anthropic usage API
/// 3. Returns typed usage data
///
/// # Errors
///
/// Returns error if:
/// - Credentials not found or expired
/// - API call fails
/// - Response parsing fails
pub fn get_usage() -> Result<UsageData, Error> {
    let token = credentials::get_token()?;
    let response = client::fetch_usage_raw(&token)?;
    let usage: UsageData = serde_json::from_str(&response)
        .map_err(|e| Error::Parse(e.to_string()))?;
    Ok(usage)
}

/// Async version of `get_usage()`
#[cfg(feature = "async")]
pub async fn get_usage_async() -> Result<UsageData, Error> {
    let token = credentials::get_token()?;
    let response = client::fetch_usage_raw_async(&token).await?;
    let usage: UsageData = serde_json::from_str(&response)
        .map_err(|e| Error::Parse(e.to_string()))?;
    Ok(usage)
}
```

### Unified Error Type

```rust
#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error(transparent)]
    Credential(#[from] CredentialError),

    #[error(transparent)]
    Api(#[from] ApiError),

    #[error("Failed to parse response: {0}")]
    Parse(String),
}
```
