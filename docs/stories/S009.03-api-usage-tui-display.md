# Story: Display Usage in TUI

**Story ID:** S009.03 **Epic:**
[E009 - API Usage Tracking](../epic/E009-api-usage-tracking.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 2

## Description

As a user, I want to see my API quota utilization in the TUI dashboard, So that
I can pace my usage and avoid hitting rate limits.

## Context

Per [D3 decision](../architecture/2026-01-31-discussion-decisions.md#d3-widget-data-flow---fully-centralized-via-daemon),
the daemon fetches usage data and broadcasts it to all subscribed TUIs. The TUI
receives this data via IPC updates, populates it into `WidgetContext`, and
passes it to the `api-usage` widget for rendering.

This story implements the TUI-side reception of usage data and the widget that
renders it in a compact format. The display shows utilization percentages and
time until rate limit reset.

Per [widget-data-flow.md](../architecture/widget-data-flow.md), widgets are
stateless renderers that only read from `WidgetContext` — no widget ever makes
external API calls.

## Implementation Details

### Technical Approach

1. Add usage data fields to `WidgetContext` (populated from daemon broadcasts)
2. Implement `api-usage` widget that reads from `WidgetContext`
3. Render quota percentages in dashboard footer or status bar
4. Support both full and compact display formats based on terminal width
5. Show "unavailable" placeholder when data is missing
6. Apply color coding for utilization levels

### Display Format

Full:

```text
Quota: 5h 8% | 7d 77% | resets 2h 15m
```

Compact:

```text
[5h:8% 7d:77%]
```

### Files to Modify

- `crates/tui/src/context.rs` — add usage fields to `WidgetContext`
- `crates/tui/src/widgets/api_usage.rs` (new) — usage display widget
- `crates/tui/src/ipc_handler.rs` — handle usage update messages from daemon
- `crates/tui/src/app.rs` — populate `WidgetContext` with received usage data

### Dependencies

- [S009.01 - Integrate claude-usage Crate](./S009.01-api-usage-data-model.md) —
  daemon must fetch and broadcast usage data
- [S004.01 - Ratatui Application Scaffold](./S004.01-ratatui-application-scaffold.md)
  — TUI application base
- [S005.01 - Widget Trait Interface](./S005.01-widget-trait-interface.md) —
  widget rendering pattern

## Acceptance Criteria

- [ ] Given usage data is broadcast from daemon, when TUI receives it, then
      `WidgetContext` is populated with 5h and 7d utilization percentages
- [ ] Given usage data is available, when the dashboard renders, then 5h and 7d
      utilization percentages are displayed
- [ ] Given usage data is unavailable, when the dashboard renders, then
      "Quota: --" placeholder is shown
- [ ] Given terminal width is narrow, when rendering, then compact format is
      used
- [ ] Given 5h utilization exceeds 80%, when displayed, then yellow color is
      applied
- [ ] Given 5h utilization exceeds 95%, when displayed, then red color is
      applied
- [ ] Given rate limit reset time is available, when displayed, then remaining
      time is shown
- [ ] Given the daemon broadcasts updated usage, when TUI receives it, then
      display updates on next render cycle
- [ ] Given the widget, when reviewed, then it never calls
      `claude_usage::get_usage()` directly (D3 compliance)

## Testing Requirements

- [ ] Unit test: Full format renders correct string for sample data
- [ ] Unit test: Compact format renders correct string
- [ ] Unit test: Unavailable state shows placeholder
- [ ] Unit test: Color thresholds apply correctly
- [ ] Unit test: Reset time formatting produces human-readable output
- [ ] Unit test: Widget reads from `WidgetContext` only, no external calls
- [ ] Integration test: TUI receives daemon broadcast and updates display

## Out of Scope

- Daemon-side usage fetching (handled in S009.01)
- Per-session token tracking display
- Usage graphs or charts over time
- Cost estimates or billing information
- Usage alerts or notifications
- Export or copy usage data

## Notes

### WidgetContext Extension

Per [widget-data-flow.md](../architecture/widget-data-flow.md#widget-contract):

```rust
use chrono::{DateTime, Utc};

pub struct WidgetContext {
    pub sessions: Vec<Session>,
    pub now: Instant,
    pub selected_index: Option<usize>,

    // Usage data from daemon
    pub usage: UsageData,
}

pub enum UsageData {
    Available {
        five_hour_pct: f64,
        seven_day_pct: f64,
        reset_time: DateTime<Utc>,
    },
    Unavailable,
}
```

### IPC Update Handler

```rust
// In TUI's IPC message handler
match message {
    UpdateMessage::Usage { five_hour_pct, seven_day_pct, reset_time } => {
        app_state.usage = UsageData::Available {
            five_hour_pct,
            seven_day_pct,
            reset_time,
        };
    }
    UpdateMessage::UsageUnavailable => {
        app_state.usage = UsageData::Unavailable;
    }
    // ... other message types
}
```

### Widget Implementation

```rust
use ratatui::widgets::Widget;
use ratatui::text::Line;
use ratatui::style::{Color, Style};

pub struct ApiUsageWidget;

impl Widget for ApiUsageWidget {
    fn render(&self, width: u16, context: &WidgetContext) -> Line<'_> {
        match &context.usage {
            UsageData::Available { five_hour_pct, seven_day_pct, reset_time } => {
                if width < 40 {
                    // Compact format
                    Line::from(format!("[5h:{:.0}% 7d:{:.0}%]",
                        five_hour_pct * 100.0,
                        seven_day_pct * 100.0
                    ))
                    .style(self.color_for_utilization(*five_hour_pct))
                } else {
                    // Full format
                    let reset_str = format_reset_time(*reset_time);
                    Line::from(format!(
                        "Quota: 5h {:.0}% | 7d {:.0}% | resets {}",
                        five_hour_pct * 100.0,
                        seven_day_pct * 100.0,
                        reset_str
                    ))
                    .style(self.color_for_utilization(*five_hour_pct))
                }
            }
            UsageData::Unavailable => {
                Line::from("Quota: --").style(Style::default().fg(Color::DarkGray))
            }
        }
    }

    fn id(&self) -> &'static str {
        "api-usage"
    }

    fn min_width(&self) -> u16 {
        15 // "[5h:0% 7d:0%]"
    }
}

impl ApiUsageWidget {
    fn color_for_utilization(&self, pct: f64) -> Style {
        if pct > 0.95 {
            Style::default().fg(Color::Red)
        } else if pct > 0.80 {
            Style::default().fg(Color::Yellow)
        } else {
            Style::default().fg(Color::Green)
        }
    }
}
```

### Color Thresholds

| Utilization | Color  |
| ----------- | ------ |
| < 80%       | Green  |
| 80% - 95%   | Yellow |
| > 95%       | Red    |

### Formatting Helpers

```rust
/// Format reset time as human-readable duration
fn format_reset_time(reset: DateTime<Utc>) -> String {
    let duration = reset - Utc::now();
    let hours = duration.num_hours();
    let minutes = duration.num_minutes() % 60;
    if hours > 0 {
        format!("{}h {}m", hours, minutes)
    } else {
        format!("{}m", minutes)
    }
}
```

### Architecture Compliance

Per [D3 decision](../architecture/2026-01-31-discussion-decisions.md#d3-widget-data-flow---fully-centralized-via-daemon)
and [widget-data-flow.md](../architecture/widget-data-flow.md#widget-constraints):

**Widget MUST:**
- Be stateless (no internal mutable state)
- Only read from `WidgetContext` parameter
- Never make external API calls
- Handle missing/unavailable data gracefully

**Widget MUST NOT:**
- Cache data between renders
- Call `claude_usage::get_usage()` directly
- Maintain timers or async tasks
- Depend on other widgets

### Graceful Degradation

When usage data is unavailable:

- Display "Quota: --" placeholder
- Log a debug message but don't show errors to user
- Continue normal operation with other widgets
