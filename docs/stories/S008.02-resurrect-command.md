# Story: Implement RESURRECT Command

**Story ID:** S008.02 **Epic:**
[E008 - Session Resurrection](../epic/E008-session-resurrection.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 5

## Description

As a user, I want a RESURRECT IPC command and CLI interface, So that I can
request resurrection of a previously closed Claude Code session.

## Context

Once closed session metadata is retained (S008.01), users need a way to trigger
the resurrection of a specific session. This story implements the RESURRECT
command in the IPC protocol and the corresponding CLI command. The command
validates that the session is resumable and returns metadata for the frontend to
use.

Per
[E008 epic scope](../epic/E008-session-resurrection.md#scope-boundary-with-e010),
the RESURRECT command is the daemon-side **protocol and metadata** interface.
This epic defines what data is returned. E010 (Zellij Integration) handles the
**terminal/pane creation** â€” invoking `claude --resume <session-id>` in the
appropriate context (see S010.03).

The RESURRECT command validates session existence and resumability, then returns
metadata. The actual `claude --resume` invocation is out of scope for this
story.

## Implementation Details

### Technical Approach

1. Add RESURRECT command to the IPC protocol
2. Implement command handler in the daemon
3. Validate session exists and is resumable
4. Validate working directory still exists
5. Return resurrection metadata (session_id, working_dir, command string)
6. Add CLI command `agent-console resurrect <session-id>`
7. Add keyboard shortcut in TUI to resurrect selected closed session

### Files to Modify

- `crates/agent-console-dashboard/src/ipc/protocol.rs` - Add RESURRECT command
  definition
- `crates/agent-console-dashboard/src/ipc/commands/mod.rs` - Add resurrect
  command module
- `crates/agent-console-dashboard/src/ipc/commands/resurrect.rs` - Create
  RESURRECT command handler
- `crates/agent-console-dashboard/src/daemon/handler.rs` - Route RESURRECT
  command to handler
- `crates/agent-console-dashboard/src/cli/commands.rs` - Add `resurrect` CLI
  subcommand
- `crates/agent-console-dashboard/src/tui/handlers.rs` - Add keyboard handler
  for resurrection

### Dependencies

- [S008.01 - Closed Session Metadata](./S008.01-closed-session-metadata.md) -
  Provides closed session data
- [S003.01 - IPC Message Protocol](./S003.01-ipc-message-protocol.md) - Defines
  protocol structure
- [S003.05 - CLI Client Commands](./S003.05-cli-client-commands.md) - CLI
  infrastructure
- [S004.03 - Keyboard Navigation](./S004.03-keyboard-navigation.md) - TUI
  keyboard handling

## Acceptance Criteria

- [ ] Given a valid closed session ID, when RESURRECT is invoked, then the
      command succeeds and returns OK with resurrection metadata
- [ ] Given an invalid session ID, when RESURRECT is invoked, then error
      "session not found" is returned
- [ ] Given a non-resumable session, when RESURRECT is invoked, then error with
      reason is returned
- [ ] Given a session with non-existent working directory, when RESURRECT is
      invoked, then error "working directory not found" is returned
- [ ] Given the CLI command `agent-console resurrect <id>`, when executed, then
      it sends RESURRECT to daemon and displays returned metadata
- [ ] Given a closed session selected in TUI, when user presses 'r', then
      RESURRECT command is triggered and metadata is displayed
- [ ] Given RESURRECT succeeds, when the command completes, then session is
      removed from closed sessions list
- [ ] Given RESURRECT fails, when the command completes, then session remains in
      closed sessions list

## Testing Requirements

- [ ] Unit test: RESURRECT command parses correctly
- [ ] Unit test: Valid session ID returns success with metadata
- [ ] Unit test: Invalid session ID returns appropriate error
- [ ] Unit test: Non-resumable session returns error with reason
- [ ] Unit test: Missing working directory validation
- [ ] Integration test: CLI command sends correct IPC message
- [ ] Integration test: Full resurrection flow from CLI
- [ ] Integration test: TUI keyboard binding triggers command

## Out of Scope

- Actual invocation of `claude --resume` (handled in S010.03)
- Zellij pane creation for resurrection (handled in E010)
- Automatic selection of where to open resurrected session
- Batch resurrection of multiple sessions

## Notes

### IPC Protocol Extension

Per [E008 epic IPC commands](../epic/E008-session-resurrection.md#ipc-commands):

```text
Request:
RESURRECT <session-id>

Response (success):
OK <json-payload>

Response (error):
ERROR <error-code> <message>

Error codes:
- SESSION_NOT_FOUND: No closed session with this ID
- NOT_RESUMABLE: Session cannot be resumed (context exceeded, etc.)
- WORKING_DIR_MISSING: Original working directory no longer exists
```

### Command Handler Implementation

```rust
use crate::daemon::store::SessionStore;
use crate::ipc::{Response, Error};
use serde::Serialize;
use std::path::PathBuf;

pub struct ResurrectCommand {
    pub session_id: String,
}

impl ResurrectCommand {
    pub fn execute(self, store: &mut SessionStore) -> Response {
        // 1. Find the closed session
        let closed = match store.get_closed(&self.session_id) {
            Some(s) => s.clone(),
            None => return Response::error(
                ErrorCode::SessionNotFound,
                format!("No closed session with ID: {}", self.session_id)
            ),
        };

        // 2. Check if resumable
        if !closed.resumable {
            return Response::error(
                ErrorCode::NotResumable,
                closed.not_resumable_reason
                    .unwrap_or_else(|| "Session cannot be resumed".to_string())
            );
        }

        // 3. Validate working directory exists
        if !closed.working_dir.exists() {
            return Response::error(
                ErrorCode::WorkingDirMissing,
                format!("Working directory no longer exists: {:?}", closed.working_dir)
            );
        }

        // 4. Prepare resurrection metadata
        let resurrection_info = ResurrectionInfo {
            session_id: closed.session_id.clone(),
            working_dir: closed.working_dir.clone(),
            command: format!("claude --resume {}", closed.session_id),
        };

        // 5. Remove from closed sessions (it's being resurrected)
        store.remove_closed(&self.session_id);

        Response::ok(serde_json::to_value(resurrection_info).unwrap())
    }
}

#[derive(Serialize)]
pub struct ResurrectionInfo {
    pub session_id: String,
    pub working_dir: PathBuf,
    pub command: String,
}
```

### CLI Command

```rust
use clap::Args;

/// Resurrect a previously closed Claude Code session
#[derive(Args)]
pub struct ResurrectArgs {
    /// Session ID to resurrect
    session_id: String,

    /// Print command without explanation (for scripting)
    #[arg(long)]
    quiet: bool,
}

impl ResurrectArgs {
    pub fn run(&self) -> Result<()> {
        let client = IpcClient::connect()?;
        let response = client.send(Command::Resurrect {
            session_id: self.session_id.clone(),
        })?;

        match response {
            Response::Ok(info) => {
                let info: ResurrectionInfo = serde_json::from_value(info)?;

                if self.quiet {
                    // For scripting: just print the command
                    println!("cd {} && {}", info.working_dir.display(), info.command);
                } else {
                    // For interactive: show explanation
                    println!("To resurrect session {}:", info.session_id);
                    println!("  cd {}", info.working_dir.display());
                    println!("  {}", info.command);
                }
            }
            Response::Error(code, msg) => {
                eprintln!("Error: {} - {}", code, msg);
                std::process::exit(1);
            }
        }

        Ok(())
    }
}
```

### TUI Integration

```rust
// In TUI key handler
KeyCode::Char('r') => {
    if let Some(selected) = state.selected_closed_session() {
        let result = ipc_client.send(Command::Resurrect {
            session_id: selected.session_id.clone(),
        });

        match result {
            Ok(Response::Ok(info)) => {
                let info: ResurrectionInfo = serde_json::from_value(info)?;
                // Show resurrection info in status bar or modal
                state.show_message(format!(
                    "Run: cd {} && {}",
                    info.working_dir.display(),
                    info.command
                ));
            }
            Ok(Response::Error(_, msg)) => {
                state.show_error(msg);
            }
            Err(e) => {
                state.show_error(format!("IPC error: {}", e));
            }
        }
    }
}
```

### Scope Boundary

Per [E008 epic](../epic/E008-session-resurrection.md#scope-boundary-with-e010):

**This epic (E008):**

- Defines RESURRECT IPC command
- Returns resurrection metadata (session_id, working_dir, command)
- Validates session existence and resumability

**E010 (Zellij Integration):**

- Invokes `claude --resume <session-id>` in terminal/pane
- Handles terminal context creation
- See S010.03 for actual execution

### Considerations

- **Execution vs. Display**: The CLI command displays the resurrection command
  for the user to execute manually. The TUI can display it in a status message.
  Actual execution requires terminal context (E010).
- **Session State**: Once RESURRECT succeeds, remove the session from closed
  sessions since it's now being resurrected.
- **Multiple Sessions Per Directory**: Per
  [Q19 decision](../epic/E008-session-resurrection.md#multiple-sessions-per-directory),
  v0/v1 relies on Claude Code's built-in session picker when multiple sessions
  exist in the same directory.
