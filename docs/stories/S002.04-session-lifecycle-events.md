# Story: Handle Session Lifecycle Events

**Story ID:** S002.04 **Epic:**
[E002 - Session Management](../epic/E002-session-management.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 5

## Description

As a developer, I want to handle session lifecycle events (create, update,
close), So that sessions are properly managed from inception to termination and
subscribers are notified of changes.

## Context

Session lifecycle management is the orchestration layer that ties together
session creation, status updates, and session closure. It ensures that:

- New sessions are properly initialized and added to the store
- Status updates are validated and broadcast to subscribers
- Closed sessions retain metadata for potential resurrection
- Subscribers (dashboards) receive real-time updates

This story integrates the data model (S002.01), status transitions (S002.02),
and state history (S002.03) into a cohesive lifecycle management system.

Key behaviors per [E002](../epic/E002-session-management.md):

- Sessions are created when the first status update arrives for an unknown
  session ID (auto-creation)
- Sessions can be explicitly closed or implicitly closed via hooks
- Closed sessions are not removed immediately - they're marked as closed for
  resurrection
- All state changes trigger notifications to subscribed clients

With the **single-threaded actor model**, all lifecycle operations are processed
sequentially through the event loop. See
[concurrency model](../architecture/concurrency.md).

## Implementation Details

### Technical Approach

1. Implement `DaemonState::create_session()` for explicit session creation
2. Implement `DaemonState::get_or_create_session()` for lazy session creation
3. Implement `DaemonState::update_session()` for status updates with subscriber
   notification
4. Implement `DaemonState::close_session()` for session closure
5. Implement `DaemonState::remove_session()` for permanent removal
6. Add subscriber notification on all state changes
7. Store operations mutate the plain HashMap directly (no locks needed with
   actor model)
8. Handle session metadata preservation for resurrection feature

### Files to Modify

- `crates/agent-console-dashboard/src/daemon/store.rs` - Add lifecycle
  management methods
- `crates/agent-console-dashboard/src/daemon/server.rs` - Wire lifecycle methods
  to IPC commands
- `crates/agent-console-dashboard/src/daemon/session.rs` - Add lifecycle-related
  methods to Session

### Dependencies

- [S002.01 - Session Data Model](./S002.01-session-data-model.md) - Session
  struct must be defined
- [S002.02 - Session Status Transitions](./S002.02-session-status-transitions.md) -
  Transition logic must be implemented
- [S002.03 - Session State History](./S002.03-session-state-history.md) -
  History recording must work
- [S001.03 - In-Memory Session Store](./S001.03-in-memory-session-store.md) -
  Store infrastructure must exist

## Acceptance Criteria

- [ ] Given a SET command for a new session ID, when processed, then a new
      session is created with the provided status
- [ ] Given a SET command for an existing session ID, when processed, then the
      session status is updated
- [ ] Given a session status update, when successful, then all subscribed
      clients receive an UPDATE message
- [ ] Given a RM command for a session, when processed, then the session is
      marked as closed (not removed from store)
- [ ] Given a closed session, when queried via LIST, then it appears with status
      "closed"
- [ ] Given a closed session, when enough time passes or explicit removal
      requested, then it can be permanently removed
- [ ] Given session creation, when the working_dir is provided, then it is
      stored with the session
- [ ] Given session creation, when the session_id (Claude Code ID) is provided,
      then it is stored for resurrection
- [ ] Given the lifecycle operations, then they mutate the plain HashMap
      directly (no Arc/RwLock)

## Testing Requirements

- [ ] Unit test: Session creation with all metadata
- [ ] Unit test: Session update triggers notification
- [ ] Unit test: Session closure marks as closed, doesn't remove
- [ ] Unit test: Closed session still appears in LIST
- [ ] Unit test: Session removal permanently deletes
- [ ] Integration test: Subscriber receives UPDATE on status change
- [ ] Integration test: Multiple subscribers all receive updates
- [ ] Integration test: Store uses plain HashMap (verify type signature)

## Out of Scope

- IPC protocol parsing (E003)
- Resurrection execution - launching Claude with --resume (E008)
- API usage tracking events (E011)
- Hook script implementation (E006)

## Notes

### Lifecycle State Diagram

```text
                    ┌─────────────────────────────────┐
                    │                                 │
                    ▼                                 │
    ┌──────────┐  SET   ┌──────────┐  SET   ┌──────────┐
    │  (none)  │───────►│  Active  │◄──────►│  Active  │
    └──────────┘        │ (Working)│        │(Attention)│
                        └────┬─────┘        └──────────┘
                             │                    │
                             │ RM                 │ RM
                             ▼                    ▼
                        ┌──────────┐
                        │  Closed  │
                        │(metadata │
                        │ retained)│
                        └────┬─────┘
                             │
                             │ (timeout or explicit)
                             ▼
                        ┌──────────┐
                        │ Removed  │
                        └──────────┘
```

### Subscriber Notification Protocol

When a session state changes, all subscribers receive:

```text
UPDATE <session_id> <status> <elapsed_seconds>
```

Example:

```text
UPDATE abc123 attention 125
```

This tells subscribers that session `abc123` changed to `attention` status after
being in the previous state for 125 seconds.

### Session Creation Metadata

On first SET command, capture from hook JSON stdin per
[D8](../architecture/2026-01-31-discussion-decisions.md):

| Field       | Source             | Required                    |
| ----------- | ------------------ | --------------------------- |
| id          | From command       | Yes                         |
| status      | From command       | Yes                         |
| working_dir | From metadata JSON | No (defaults to unknown)    |
| session_id  | From metadata JSON | No (Claude Code specific)   |
| agent_type  | From metadata JSON | No (defaults to ClaudeCode) |

Example SET command with metadata:

```text
SET abc123 working {"working_dir":"/home/user/project","session_id":"claude-abc"}
```

### Store Pattern - No Locks

With single-threaded actor model:

```rust
// Plain HashMap owned by event loop
struct DaemonState {
    sessions: HashMap<String, Session>,
    subscribers: Vec<mpsc::Sender<String>>,
}

impl DaemonState {
    fn update_session(&mut self, id: &str, status: Status) {
        if let Some(session) = self.sessions.get_mut(id) {
            session.set_status(status);
            // Broadcast to subscribers
            self.broadcast_update(id, status);
        }
    }

    fn broadcast_update(&mut self, id: &str, status: Status) {
        let msg = format!("UPDATE {} {}\n", id, status);
        // Send to all, remove failed sends
        self.subscribers.retain(|tx| tx.try_send(msg.clone()).is_ok());
    }
}
```

### Cleanup Strategy

Closed sessions should be cleaned up to prevent unbounded memory growth.

Recommendation per [E002](../epic/E002-session-management.md): Time-based
cleanup (default 30 minutes) with configuration option.

```toml
[sessions]
closed_session_retention_minutes = 30
```

Implement cleanup as part of the auto-stop interval check (runs every 5
minutes).

### Concurrency Note

The **single-threaded actor model** eliminates all concurrency concerns. The
event loop processes one message at a time, mutating the HashMap directly. No
Arc, no RwLock, no race conditions. See
[concurrency model](../architecture/concurrency.md) and
[D1](../architecture/2026-01-31-discussion-decisions.md).
