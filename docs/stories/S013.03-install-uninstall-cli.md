# Story: Implement Install/Uninstall CLI

**Story ID:** S013.03 **Epic:**
[E013 - Deployment Infrastructure](../epic/E013-deployment-infrastructure.md)
**Status:** Draft **Priority:** P2 **Estimated Points:** 3

## Description

As a user, I want to run `acd service install`, `acd service uninstall`, and
`acd service status` to manage the daemon as a system service, So that I don't
need to manually copy service files or run platform-specific commands.

## Context

S013.01 and S013.02 create the service files (launchd plist, systemd unit). This
story provides CLI commands that copy those files to the correct locations, run
the platform-specific registration commands, and check service status. Per the
epic, the `status` command delegates to native tools (`launchctl`/`systemctl`).

## Implementation Details

### Technical Approach

1. Add `service` subcommand group to CLI with `install`, `uninstall`, and
   `status` actions
2. Detect platform at runtime (`#[cfg(target_os)]`)
3. On install: copy service file to correct location, run registration command,
   validate registration
4. On uninstall: stop service, remove service file, confirm removal
5. On status: delegate to `launchctl`/`systemctl` and parse output
6. Print clear status messages for each step

### CLI Commands

```bash
acd service install     # Copy plist/unit file, register service
acd service uninstall   # Stop service, remove files
acd service status      # Check service status (delegates to launchctl/systemctl)
```

### Platform Behavior

| Action    | macOS                                                                | Linux                                                                    |
| --------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| Install   | Copy plist to ~/Library/LaunchAgents, `launchctl load`, verify       | Copy unit to ~/.config/systemd/user, `systemctl --user enable`, verify  |
| Uninstall | `launchctl bootout`, remove plist, verify removal                    | `systemctl --user stop`, `systemctl --user disable`, remove unit, verify removal |
| Status    | `launchctl list \| grep com.agent-console`, parse output             | `systemctl --user is-enabled acd`, parse output                          |

### Install Validation

After `acd service install`, verify the service registered correctly:

- **macOS:** Check `launchctl list | grep com.agent-console` returns a result
- **Linux:** Check `systemctl --user is-enabled acd.service` returns "enabled"

Report success/failure to the user with next steps if registration failed.

### Uninstall Sequence

`acd service uninstall` follows this sequence:

1. Stop service (macOS: `launchctl bootout`, Linux: `systemctl --user stop`)
2. Remove the service file (plist or unit file)
3. Verify removal (check file no longer exists)
4. Report success to user

### Files Modified

- `crates/agent-console-dashboard/src/main.rs` - Add `Service` subcommand with
  `Install`, `Uninstall`, and `Status` actions

### Files Created

- `crates/agent-console-dashboard/src/service.rs` - Platform-specific
  install/uninstall/status logic

### Dependencies

- [S013.01 - macOS launchd Plist](./S013.01-macos-launchd-plist.md) - Plist
  file to install
- [S013.02 - Linux systemd Unit File](./S013.02-linux-systemd-unit-file.md) -
  Unit file to install

## Acceptance Criteria

- [ ] `acd service install` copies service file to correct platform location
- [ ] `acd service install` registers/enables the service
- [ ] `acd service install` validates successful registration
- [ ] `acd service uninstall` stops the daemon before removal
- [ ] `acd service uninstall` removes the service file
- [ ] `acd service uninstall` confirms removal
- [ ] `acd service status` delegates to `launchctl`/`systemctl`
- [ ] `acd service status` displays service state (running/stopped/not installed)
- [ ] Clear success/error messages for each step
- [ ] Idempotent: running install twice doesn't error (replaces existing)
- [ ] `cargo test --workspace` passes
- [ ] `cargo clippy --workspace` passes
- [ ] Given an unsupported platform (not macOS or Linux), when
      install/uninstall is attempted, then a clear error message is shown:
      "Platform not supported. Only macOS (launchd) and Linux (systemd) are
      supported."

## Testing Requirements

- [ ] Unit test: platform detection returns correct value
- [ ] Unit test: install path construction for macOS
- [ ] Unit test: install path construction for Linux
- [ ] Manual test: full install/status/uninstall cycle on macOS
- [ ] Manual test: full install/status/uninstall cycle on Linux
- [ ] Manual test: install when service already installed (idempotent)
- [ ] Manual test: uninstall when service not installed (graceful error)

## Out of Scope

- Windows service management
- Upgrading an existing service installation (covered by idempotent install)
- Custom service file paths (use standard locations only)

## Notes

### Platform Detection

```rust
#[cfg(target_os = "macos")]
fn install_service() -> Result<()> {
    // launchd implementation
}

#[cfg(target_os = "linux")]
fn install_service() -> Result<()> {
    // systemd implementation
}
```

### Service File Validation

Before copying service files, validate them:

- **macOS:** `plutil -lint` on the plist file
- **Linux:** `systemd-analyze verify` on the unit file (if available)

### macOS Install Steps

```rust
fn install_macos() -> Result<()> {
    let dest = dirs::home_dir()?
        .join("Library/LaunchAgents/com.agent-console.daemon.plist");

    // Service file templates are embedded at compile time via include_str!
    // so they work after cargo install.
    let plist_content = include_str!("../../resources/com.agent-console.daemon.plist");

    // Load service
    Command::new("launchctl")
        .args(["load", dest.to_str().unwrap()])
        .status()?;

    // Validate
    let output = Command::new("launchctl")
        .args(["list"])
        .output()?;

    if !String::from_utf8_lossy(&output.stdout).contains("com.agent-console") {
        return Err("Service registration failed".into());
    }

    println!("Service installed successfully");
    Ok(())
}
```

### Linux Install Steps

```rust
fn install_linux() -> Result<()> {
    let dest = dirs::home_dir()?
        .join(".config/systemd/user/acd.service");

    // Create directory if needed
    std::fs::create_dir_all(dest.parent().unwrap())?;

    // Service file templates are embedded at compile time via include_str!
    // so they work after cargo install.
    let unit_content = include_str!("../../resources/acd.service");
    std::fs::write(&dest, unit_content)?;

    // Enable and start service
    Command::new("systemctl")
        .args(["--user", "enable", "acd.service"])
        .status()?;

    Command::new("systemctl")
        .args(["--user", "start", "acd.service"])
        .status()?;

    // Validate
    let output = Command::new("systemctl")
        .args(["--user", "is-enabled", "acd.service"])
        .output()?;

    if !String::from_utf8_lossy(&output.stdout).contains("enabled") {
        return Err("Service registration failed".into());
    }

    println!("Service installed and started successfully");
    Ok(())
}
```

### Status Output Examples

**macOS (running):**

```text
Service status: running (via launchd)
PID: 12345
```

**Linux (running):**

```text
Service status: active (running)
```

**Not installed:**

```text
Service status: not installed
Run 'acd service install' to set up the service
```

### Interaction with Auto-Start

Per the epic, service management and auto-start (E001 S001.04) are complementary:

- **Without service:** Auto-start on first hook/dashboard connection
- **With service:** Daemon always running, auto-start becomes a no-op

Users can choose either approach. Service management is optional.
