# Story: Define IPC Message Protocol

**Story ID:** S003.01 **Epic:**
[E003 - IPC Protocol & Client](../epic/E003-ipc-protocol-and-client.md)
**Status:** Draft **Priority:** P1 **Estimated Points:** 5

## Description

As a developer, I want to define a text-based IPC message protocol, So that
hooks, clients, and the daemon can communicate reliably over Unix sockets.

## Context

The IPC protocol is the communication layer between all components of the Agent
Console system. Hooks use it to report session status changes, CLI clients use
it for queries and commands, and the TUI dashboard uses it for real-time
subscriptions. The protocol must be simple enough for easy debugging while being
robust enough for reliable communication.

Per [D2](../architecture/2026-01-31-discussion-decisions.md), the protocol uses
**JSON Lines** (one JSON object per `\n`-delimited line) over Unix socket:

- JSON serializers escape `\n` inside strings, so no framing ambiguity
- Human-readable for easy debugging (can use `nc` or `socat` to test)
- Simple parsing (newline-delimited messages)
- Transport-independent: Unix socket now, named pipes for Windows later, same
  wire format

## Implementation Details

### Technical Approach

1. Create `crates/agent-console-dashboard/src/daemon/protocol.rs` for message
   types and parsing
2. Define `Command` enum for client-to-daemon messages
3. Define `Response` enum for daemon-to-client messages
4. Implement `FromStr` for parsing incoming JSON Lines
5. Implement `Display` for serializing responses as JSON Lines
6. Handle edge cases (malformed messages, unknown commands)

### Message Format - JSON Lines

Per [D2](../architecture/2026-01-31-discussion-decisions.md):

```text
# Commands (client -> daemon) - one JSON object per line
{"type":"SET","session":"abc","status":"working","metadata":{"cwd":"/path"}}
{"type":"RM","session":"abc"}
{"type":"LIST"}
{"type":"SUBSCRIBE"}
{"type":"RESURRECT","session":"abc"}

# Responses (daemon -> client) - one JSON object per line
{"type":"OK"}
{"type":"OK","data":[...]}
{"type":"ERR","message":"error description"}
{"type":"STATE","sessions":[...]}
{"type":"UPDATE","session":"abc","status":"working","elapsed":45}
```

Each message is a single JSON object terminated by `\n`.

### Files to Create/Modify

- `crates/agent-console-dashboard/src/daemon/protocol.rs` - Create new file for
  protocol types
- `crates/agent-console-dashboard/src/daemon/mod.rs` - Export protocol module
- `crates/agent-console-dashboard/src/lib.rs` - Add shared protocol types if
  needed

### Dependencies

- [S001.02 - Unix Socket Server](./S001.02-unix-socket-server.md) - Protocol
  messages flow over the socket
- [S002.01 - Session Data Model](./S002.01-session-data-model.md) - Protocol
  references session status types

## Acceptance Criteria

- [ ] Given a valid SET command JSON, when parsed, then returns `Command::Set`
      with correct session, status, and optional metadata
- [ ] Given a valid LIST command JSON, when parsed, then returns `Command::List`
- [ ] Given a valid SUBSCRIBE command JSON, when parsed, then returns
      `Command::Subscribe`
- [ ] Given a malformed JSON, when parsed, then returns an appropriate parse
      error
- [ ] Given a `Response::Ok`, when serialized, then produces JSON with `\n`
      terminator
- [ ] Given a `Response::Error`, when serialized, then produces JSON with error
      message and `\n` terminator
- [ ] Given any message, then it is newline-delimited for stream framing (JSON
      Lines format)
- [ ] Given the protocol implementation, then it includes `"version":1` in
      messages for forward compatibility

## Testing Requirements

- [ ] Unit test: Parse SET command with all valid status values (working,
      attention, question)
- [ ] Unit test: Parse SET command with optional JSON metadata
- [ ] Unit test: Parse all command types (SET, RM, LIST, SUBSCRIBE, RESURRECT)
- [ ] Unit test: Parse errors for malformed JSON
- [ ] Unit test: Response serialization round-trip (JSON Lines format)
- [ ] Unit test: Handle edge cases (empty strings, extra whitespace, embedded
      newlines in strings)

## Out of Scope

- Actual command execution (handled by individual command stories)
- Socket transport layer (S001.02)
- TLS/encryption (not needed for local Unix socket)

## Notes

### Command Enum Design

```rust
#[derive(Debug, Clone, Deserialize)]
#[serde(tag = "type")]
pub enum Command {
    #[serde(rename = "SET")]
    Set {
        session: String,
        status: Status,
        #[serde(default)]
        metadata: Option<serde_json::Value>,
    },
    #[serde(rename = "RM")]
    Remove { session: String },
    #[serde(rename = "LIST")]
    List,
    #[serde(rename = "SUBSCRIBE")]
    Subscribe,
    #[serde(rename = "RESURRECT")]
    Resurrect { session: String },
}

#[derive(Debug, Clone, Serialize)]
#[serde(tag = "type")]
pub enum Response {
    #[serde(rename = "OK")]
    Ok {
        #[serde(skip_serializing_if = "Option::is_none")]
        data: Option<serde_json::Value>,
    },
    #[serde(rename = "ERR")]
    Error { message: String },
    #[serde(rename = "STATE")]
    State { sessions: Vec<SessionInfo> },
    #[serde(rename = "UPDATE")]
    Update {
        session: String,
        status: Status,
        elapsed: u64,
    },
}
```

### Key Dependencies

| Crate      | Purpose                     |
| ---------- | --------------------------- |
| serde      | Serialization derive macros |
| serde_json | JSON parsing/serialization  |

### Design Decisions

Per [E003](../epic/E003-ipc-protocol-and-client.md) and
[D2](../architecture/2026-01-31-discussion-decisions.md):

- **JSON Lines format** — One JSON object per `\n`-delimited line
- **Transport-independent** — JSON Lines is the wire format. Unix socket is the
  transport (Linux/macOS). Future Windows: named pipes. Future v1+: could swap
  to TCP or SQLite without changing wire format.
- **Push model for subscriptions** — Server pushes updates, clients don't poll
- **SUBSCRIBE semantics** — Sends full state snapshot first, then deltas on
  change
- **Protocol version** — Include `"version": 1` in messages for forward
  compatibility

### JSON Lines Framing

Each message MUST be a single line (newline-terminated JSON):

```json
{"type":"SET","session":"abc","status":"working"}\n
{"type":"OK"}\n
```

JSON serializers escape embedded newlines in strings, so there is no ambiguity:

```json
{"type":"SET","session":"abc","metadata":{"note":"line1\nline2"}}\n
```

The newline in the note value is escaped as `\n`, so the message is still a
single line.

### Complexity Review Notes

Per [complexity review](../decisions/complexity-review.md), consolidate during
implementation:

- `remove()` vs `remove_session()` — duplicate methods to consolidate
- `get_or_create_session()` — consider simplifying
- Full serde serialization may be appropriate for JSON Lines protocol

Address these during implementation of this story.
