# Story: Create Widget Trait/Interface

**Story ID:** S005.01 **Epic:**
[E005 - Widget System](../epic/E005-widget-system.md) **Status:** Draft
**Priority:** P1 **Estimated Points:** 5

## Description

As a developer, I want to create a widget trait that defines the interface for
all UI widgets, So that all widgets have a consistent contract for rendering and
configuration.

## Context

The Agent Console Dashboard uses a widget-based architecture where each line in
the display is a widget. This trait defines the fundamental contract that all
widgets must implement: rendering output, providing an identifier for
configuration, and specifying minimum width requirements.

The widget system enables users to compose custom layouts by selecting and
ordering widgets. A consistent interface ensures widgets can be dynamically
selected, configured, and rendered by the layout system.

## Implementation Details

### Technical Approach

1. Create `src/widgets/mod.rs` as the widget module entry point
2. Define the `Widget` trait with required methods
3. Define `WidgetContext` struct to provide shared state to widgets
4. Create widget registry for dynamic widget lookup by ID
5. Implement widget factory function for configuration-based instantiation
6. Add support for widget styling via Ratatui's `Line` and `Span` types

### Files to Modify

- `src/widgets/mod.rs` - Widget trait definition, registry, and exports
- `src/widgets/context.rs` - WidgetContext struct with shared state
- `src/lib.rs` - Add widgets module export

### Dependencies

- [S004.01 - Ratatui Application Scaffold](./S004.01-ratatui-application-scaffold.md) -
  Provides Ratatui types for styled output
- [S002.01 - Session Data Model](./S002.01-session-data-model.md) - Session data
  needed by session-status widget

## Acceptance Criteria

- [ ] Given a Widget trait is defined, when a struct implements it, then it must
      provide `render()`, `id()`, and `min_width()` methods
- [ ] Given the `render()` method is called, when provided width and context,
      then it returns a styled `Line` for display
- [ ] Given a widget ID, when looked up in the registry, then the corresponding
      widget factory is returned
- [ ] Given the `min_width()` is queried, when terminal is narrower, then layout
      system can decide to hide widget
- [ ] Given WidgetContext is passed to render, when widget needs session data,
      then it can access current sessions
- [ ] Given WidgetContext is passed to render, when widget needs time, then it
      can access current timestamp

## Testing Requirements

- [ ] Unit test: Widget trait can be implemented by a mock widget
- [ ] Unit test: Widget registry returns correct factory for known IDs
- [ ] Unit test: Widget registry returns None for unknown IDs
- [ ] Unit test: WidgetContext provides access to session data

## Out of Scope

- Implementing actual widgets (S005.02-S005.04)
- Layout preset system (S005.05)
- Widget configuration from TOML (E007)
- Widget orientation modes (vertical/horizontal)

## Notes

### Widget Trait Definition

```rust
use ratatui::text::Line;

/// Context passed to widgets during rendering
pub struct WidgetContext<'a> {
    /// Current sessions to display
    pub sessions: &'a [Session],
    /// Current timestamp for time-based widgets
    pub now: chrono::DateTime<chrono::Local>,
    /// Selected session index (if any)
    pub selected_index: Option<usize>,
    /// API usage data (if available)
    pub api_usage: Option<&'a ApiUsage>,
}

/// Trait that all dashboard widgets must implement
pub trait Widget: Send + Sync {
    /// Render the widget to a single line of styled text
    ///
    /// # Arguments
    /// * `width` - Available terminal width in columns
    /// * `context` - Shared context with session data and state
    ///
    /// # Returns
    /// A styled Line for Ratatui rendering
    fn render(&self, width: u16, context: &WidgetContext) -> Line<'_>;

    /// Widget identifier for configuration lookup
    fn id(&self) -> &'static str;

    /// Minimum width required for meaningful display
    ///
    /// Layout system may hide widget if terminal is narrower
    fn min_width(&self) -> u16;
}
```

### Widget Registry Pattern

```rust
use std::collections::HashMap;

type WidgetFactory = fn() -> Box<dyn Widget>;

pub struct WidgetRegistry {
    factories: HashMap<&'static str, WidgetFactory>,
}

impl WidgetRegistry {
    pub fn new() -> Self {
        let mut registry = Self {
            factories: HashMap::new(),
        };

        // Register built-in widgets
        registry.register("session-status", || Box::new(SessionStatusWidget::new()));
        registry.register("working-dir", || Box::new(WorkingDirWidget::new()));
        registry.register("api-usage", || Box::new(ApiUsageWidget::new()));
        registry.register("state-history", || Box::new(StateHistoryWidget::new()));
        registry.register("clock", || Box::new(ClockWidget::new()));
        registry.register("spacer", || Box::new(SpacerWidget::new()));

        registry
    }

    pub fn register(&mut self, id: &'static str, factory: WidgetFactory) {
        self.factories.insert(id, factory);
    }

    pub fn create(&self, id: &str) -> Option<Box<dyn Widget>> {
        self.factories.get(id).map(|f| f())
    }
}
```

### Project Structure

```text
src/
├── widgets/
│   ├── mod.rs           # Widget trait, registry, re-exports
│   └── context.rs       # WidgetContext definition
```

### Design Considerations

- Widgets are immutable after creation - all state comes from WidgetContext
- The `'_` lifetime in `Line<'_>` allows returning styled text without lifetime
  complications
- `Send + Sync` bound enables widgets to be stored in shared state across async
  tasks
- min_width allows graceful degradation on narrow terminals
