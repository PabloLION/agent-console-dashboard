# Story: Implement Health Check Command

**Story ID:** S012.02 **Epic:**
[E012 - Logging and Diagnostics](../epic/E012-logging-and-diagnostics.md)
**Status:** Ready for Dev **Priority:** P2 **Estimated Points:** 3

## Description

As a user running the daemon, I want to run `acd status` to check if the daemon
is healthy and see key metrics, So that I can quickly verify it is running and
inspect its state without parsing log files.

## Context

The daemon runs as a background process. When something seems wrong (dashboard
not updating, hooks not firing), the first diagnostic step is checking whether
the daemon is alive and responsive. The `acd status` command connects to the
daemon via the Unix socket, requests health information, and displays it in a
human-readable format.

This requires both a new CLI subcommand and a new IPC command (`STATUS`) in the
socket server protocol.

## Implementation Details

### Technical Approach

1. Add `STATUS` IPC command to the socket server that returns health data as
   JSON
2. Track daemon start time in `SocketServer` (for uptime calculation)
3. Add `status` subcommand to the CLI that:
   - Connects to the daemon socket
   - Sends `STATUS` command
   - Parses the JSON response
   - Displays human-readable output
   - Exits with code 0 if healthy, 1 if daemon unreachable
4. Use the existing `client` module for socket communication

### IPC Protocol

```text
STATUS
  Returns: OK <json>
  JSON payload: {"uptime_seconds":9240,"sessions":{"active":3,"closed":1},"socket_path":"/tmp/agent-console.sock"}
```

### CLI Output

```text
Agent Console Daemon
  Status:      running
  Uptime:      2h 34m
  Sessions:    3 active, 1 closed
  Socket:      /tmp/agent-console.sock
```

When daemon is unreachable:

```text
Agent Console Daemon
  Status:      not running
```

### Files to Modify

- `crates/agent-console-dashboard/src/main.rs` — add `Status` subcommand
- `crates/agent-console-dashboard/src/daemon/server.rs` — add `STATUS` command
  handler, track start time
- `crates/agent-console-dashboard/src/lib.rs` — add `HealthStatus` response type

### Dependencies

- S012.01 (structured logging) — completed

## Acceptance Criteria

- [ ] `acd status` connects to daemon and displays health info
- [ ] Output includes: status, uptime, session count (active/closed), socket
      path
- [ ] Exit code 0 when daemon is running, 1 when unreachable
- [ ] `STATUS` IPC command returns JSON response
- [ ] Daemon tracks start time for uptime calculation
- [ ] `cargo test --workspace` passes
- [ ] `cargo clippy --workspace` passes

## Testing Requirements

- [ ] Unit test: `STATUS` command handler returns valid JSON
- [ ] Unit test: uptime formatting (seconds → human-readable)
- [ ] Unit test: health status response parsing
- [ ] Integration test: `STATUS` command via socket (feature-gated if needed)
- [ ] Manual test: `acd status` with daemon running
- [ ] Manual test: `acd status` with daemon stopped (exit code 1)

## Out of Scope

- Memory usage reporting (requires platform-specific APIs, defer to v2)
- Connection count tracking (defer to S012.03 dump command or later)
- JSON output format flag (`--format json`) — defer to S012.03

## Notes

### Uptime Formatting

```rust
fn format_uptime(seconds: u64) -> String {
    let hours = seconds / 3600;
    let minutes = (seconds % 3600) / 60;
    if hours > 0 {
        format!("{}h {}m", hours, minutes)
    } else {
        format!("{}m", minutes)
    }
}
```

### Health Status Type

```rust
#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct HealthStatus {
    pub uptime_seconds: u64,
    pub sessions: SessionCounts,
    pub socket_path: String,
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct SessionCounts {
    pub active: usize,
    pub closed: usize,
}
```

### Scope Simplification

The epic originally listed memory usage and connection count in the health check
output. Memory usage requires `sysinfo` or `/proc` parsing which adds complexity
and a platform dependency. Connection count requires tracking active connections
in the server. Both are deferred — uptime and session count provide the most
actionable diagnostic information for v0.
