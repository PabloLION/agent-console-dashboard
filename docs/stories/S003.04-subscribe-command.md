# Story: Implement SUBSCRIBE Command

**Story ID:** S003.04 **Epic:**
[E003 - IPC Protocol & Client](../epic/E003-ipc-protocol-and-client.md)
**Status:** Draft **Priority:** P1 **Estimated Points:** 5

## Description

As a TUI dashboard, I want to subscribe to real-time session updates, So that I
can display live status changes without polling.

## Context

The SUBSCRIBE command is the foundation of the real-time dashboard experience.
Instead of polling the daemon repeatedly, clients subscribe once and receive a
stream of updates as sessions change state. This push model enables:

- Instant UI updates when sessions change
- Low daemon CPU usage (no polling overhead)
- Efficient network usage (only changed data is sent)

The subscription is long-lived - the connection stays open and the daemon pushes
UPDATE messages whenever session state changes. The client receives the current
state immediately upon subscribing, then continuous updates thereafter.

## Implementation Details

### Technical Approach

1. Add SUBSCRIBE command handler in daemon server
2. Send initial STATE message with all current sessions
3. Register client connection in subscriber list
4. When any session changes, push UPDATE to all subscribers
5. Handle client disconnection (remove from subscriber list)
6. Support multiple concurrent subscribers

### Protocol Format

```text
# Request
SUBSCRIBE

# Initial Response
STATE <json_array_of_all_sessions>

# Subsequent Updates (pushed by daemon)
UPDATE <session> <status> <elapsed_seconds>
UPDATE session-abc123 working 0
UPDATE session-abc123 attention 45
UPDATE session-def456 question 5

# On session removal
UPDATE <session> closed 120
```

### Files to Modify

- `src/daemon/server.rs` - Add SUBSCRIBE handler and subscriber management
- `src/daemon/store.rs` - Add subscriber notification on state changes
- `src/daemon/mod.rs` - Add subscriber list type

### Dependencies

- [S003.01 - IPC Message Protocol](./S003.01-ipc-message-protocol.md) - Protocol
  definition
- [S001.03 - In-Memory Session Store](./S001.03-in-memory-session-store.md) - Store to
  observe
- [S003.02 - SET Command](./S003.02-set-command.md) - Triggers update broadcasts

## Acceptance Criteria

- [ ] Given a new subscriber, when SUBSCRIBE is called, then initial STATE with
      all sessions is sent
- [ ] Given an active subscription, when any session changes, then UPDATE
      message is pushed
- [ ] Given multiple subscribers, when a session changes, then all subscribers
      receive UPDATE
- [ ] Given a subscriber disconnects, when detected, then subscriber is removed
      from list
- [ ] Given the connection is open, then it remains open indefinitely (no
      timeout)
- [ ] Given an UPDATE, then format is `UPDATE <session> <status> <elapsed>\n`
- [ ] Given 10+ concurrent subscribers, then system handles all correctly

## Testing Requirements

- [ ] Unit test: SUBSCRIBE sends initial STATE response
- [ ] Unit test: Subscriber list correctly tracks active connections
- [ ] Unit test: Disconnected subscribers are cleaned up
- [ ] Integration test: SET command triggers UPDATE to subscriber
- [ ] Integration test: Multiple subscribers all receive updates
- [ ] Integration test: Subscriber receives updates after initial state
- [ ] Integration test: Connection stays open for extended periods

## Out of Scope

- Filtered subscriptions (subscribe to specific sessions only)
- Replay of missed updates (if client was disconnected)
- Acknowledgment of received updates
- Backpressure handling for slow clients

## Notes

### Subscriber Management

```rust
// Subscriber list (in daemon state)
type Subscribers = Vec<mpsc::Sender<String>>;

// When session changes
async fn broadcast_update(subscribers: &Subscribers, update: &str) {
    // Send to all, remove failed sends
    subscribers.retain(|tx| tx.try_send(update.to_string()).is_ok());
}
```

### UPDATE Message Format

```text
UPDATE <session_id> <status> <elapsed_seconds>
```

- `session_id`: The session that changed
- `status`: New status (working, attention, question, closed)
- `elapsed_seconds`: How long the session was in the previous status

### Connection Lifecycle

```text
Client                          Daemon
  |                               |
  |-------- SUBSCRIBE ----------->|
  |                               |
  |<-------- STATE [...] ---------|  Initial state
  |                               |
  |<-------- UPDATE s1 work 0 ----|  Real-time updates
  |<-------- UPDATE s1 attn 45 ---|
  |<-------- UPDATE s2 ques 10 ---|
  |                               |
  |-------- [disconnect] -------->|  Client closes
  |                               |
```

### Error Handling

- If sending to subscriber fails, assume disconnected and remove
- No retry logic needed (subscriber can reconnect)
- Log subscriber count changes for debugging

### Performance Considerations

- Use async broadcast (don't block SET command waiting for slow subscribers)
- Consider bounded channel to prevent memory growth from slow subscribers
- Update messages are small (~50 bytes), bandwidth is not a concern
