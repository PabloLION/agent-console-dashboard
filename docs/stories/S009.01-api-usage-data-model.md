# Story: Integrate claude-usage Crate

**Story ID:** S009.01 **Epic:**
[E009 - API Usage Tracking](../epic/E009-api-usage-tracking.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 3

## Description

As a developer, I want the daemon to integrate the `claude-usage` crate and
fetch account-level quota data periodically, So that usage information is
available to all subscribed TUIs.

## Context

Per [E009 epic](../epic/E009-api-usage-tracking.md) and
[D3 decision](../architecture/2026-01-31-discussion-decisions.md#d3-widget-data-flow---fully-centralized-via-daemon),
the **daemon** is the single source of truth for ALL data, including API usage.
The daemon calls `claude_usage::get_usage()` periodically and broadcasts the
result to all subscribed TUIs.

This centralized architecture prevents N TUIs from making N redundant API calls
(wasteful, risks rate limiting). See
[widget-data-flow.md](../architecture/widget-data-flow.md) for the full
rationale.

Per
[D4 decision](../architecture/2026-01-31-discussion-decisions.md#d4-usage-fetch-interval---3-minutes),
the daemon fetches usage every 3 minutes (aligns with 1% accuracy granularity
for 5h window). Fetching only occurs when ≥1 TUI is subscribed.

No per-session token tracking is needed. Claude Code does not currently expose
per-session token counts via hooks. Account-level quota from E011 provides the
most actionable information.

## Implementation Details

### Technical Approach

1. Add `claude-usage` as a dependency in the daemon crate's `Cargo.toml`
2. Create a periodic fetch task that calls `claude_usage::get_usage()` every 3
   minutes
3. Store the fetched `UsageResponse` in daemon state
4. Broadcast usage data to all subscribed TUIs via existing update mechanism
5. Handle credential/network errors gracefully (broadcast "unavailable" state)
6. Conditionally fetch only when ≥1 TUI is subscribed (D3)

### Files to Modify

- `crates/daemon/Cargo.toml` — add `claude-usage` dependency
- `crates/daemon/src/usage.rs` (new) — periodic usage fetch task
- `crates/daemon/src/state.rs` — add usage data to daemon state
- `crates/daemon/src/broadcast.rs` — include usage in TUI update broadcasts
- `crates/daemon/src/main.rs` — spawn usage fetch task

### Dependencies

- [E011 - Claude Usage Crate](../epic/E011-claude-usage-crate.md) — provides
  `get_usage()` API
- [E001 - Daemon Core Infrastructure](../epic/E001-daemon-core-infrastructure.md)
  — daemon must exist
- [E003 - IPC Protocol & Client](../epic/E003-ipc-protocol-and-client.md) —
  broadcast mechanism

## Acceptance Criteria

- [ ] Given the daemon starts, when ≥1 TUI is subscribed, then
      `claude_usage::get_usage()` is called every 3 minutes
- [ ] Given no TUI is subscribed, when daemon is running, then no usage API
      calls are made
- [ ] Given a successful API response, when fetched, then 5h and 7d utilization
      percentages are stored in daemon state
- [ ] Given a credential error, when fetch fails, then daemon broadcasts
      "unavailable" status without crashing
- [ ] Given a network error, when fetch fails, then previous data is retained,
      error is logged, and retry happens on next interval
- [ ] Given multiple TUIs subscribed, when usage is fetched, then all TUIs
      receive the same update simultaneously
- [ ] Given fetch interval is configurable, when config sets
      `usage_fetch_interval = "3m"`, then daemon fetches every 3 minutes

## Testing Requirements

- [ ] Unit test: Usage fetch task calls `claude_usage::get_usage()` correctly
- [ ] Unit test: Error handling sets state to unavailable
- [ ] Unit test: Fetch interval respects configuration (3m default)
- [ ] Unit test: Fetch only occurs when ≥1 TUI subscribed
- [ ] Integration test: `claude_usage::get_usage()` call succeeds with valid
      credentials
- [ ] Integration test: Broadcast contains usage data
- [ ] Integration test: Multiple TUIs receive identical usage data

## Out of Scope

- Per-session token tracking (no data source available)
- Cost estimates
- TUI-side usage fetching (daemon owns all data per D3)
- Display formatting (handled in S009.03)

## Notes

### Daemon State Extension

```rust
use claude_usage::types::UsageResponse;
use std::sync::{Arc, Mutex};

pub struct DaemonState {
    // ... existing fields ...

    /// Account-level usage data from claude-usage crate
    pub usage: Arc<Mutex<Option<UsageResponse>>>,

    /// Whether the last usage fetch failed
    pub usage_unavailable: Arc<Mutex<bool>>,

    /// Count of subscribed TUIs
    pub tui_subscriber_count: Arc<Mutex<usize>>,
}
```

### Periodic Fetch Task

Per
[D3](../architecture/2026-01-31-discussion-decisions.md#d3-widget-data-flow---fully-centralized-via-daemon)
and
[D4](../architecture/2026-01-31-discussion-decisions.md#d4-usage-fetch-interval---3-minutes):

```rust
use claude_usage::get_usage;
use tokio::time::{interval, Duration};

/// Fetch usage data periodically (every 3 minutes, only when ≥1 TUI subscribed)
async fn fetch_usage_loop(state: Arc<DaemonState>) {
    let mut ticker = interval(Duration::from_secs(180)); // 3 minutes

    loop {
        ticker.tick().await;

        // Only fetch if we have subscribers (D3 conditional fetching)
        let subscriber_count = *state.tui_subscriber_count.lock().unwrap();
        if subscriber_count == 0 {
            tracing::debug!("No TUI subscribers, skipping usage fetch");
            continue;
        }

        tracing::debug!("Fetching usage data ({} subscribers)", subscriber_count);

        match get_usage() {
            Ok(data) => {
                *state.usage.lock().unwrap() = Some(data.clone());
                *state.usage_unavailable.lock().unwrap() = false;

                // Broadcast to all TUIs
                state.broadcast_usage_update(data);
            }
            Err(e) => {
                tracing::warn!("Usage fetch failed: {}", e);
                *state.usage_unavailable.lock().unwrap() = true;

                // Broadcast unavailable status
                state.broadcast_usage_unavailable();
            }
        }
    }
}
```

### Configuration

Per [E007 epic](../epic/E007-configuration-system.md#configuration-schema):

```toml
[daemon]
usage_fetch_interval = "3m"  # default: 3 minutes (D4)
```

Valid values: `"1m"`, `"3m"`, `"5m"`, `"10m"`

Warning: Interval < 1 minute risks rate limiting from Anthropic API.

### Broadcast Mechanism

```rust
impl DaemonState {
    /// Broadcast usage update to all subscribed TUIs
    fn broadcast_usage_update(&self, usage: UsageResponse) {
        let message = UpdateMessage::Usage {
            five_hour_pct: usage.five_hour_utilization,
            seven_day_pct: usage.seven_day_utilization,
            reset_time: usage.reset_time,
        };

        for tui_client in &self.tui_clients {
            if let Err(e) = tui_client.send(message.clone()) {
                tracing::error!("Failed to send usage update to TUI: {}", e);
            }
        }
    }

    fn broadcast_usage_unavailable(&self) {
        let message = UpdateMessage::UsageUnavailable;

        for tui_client in &self.tui_clients {
            if let Err(e) = tui_client.send(message.clone()) {
                tracing::error!("Failed to send unavailable status to TUI: {}", e);
            }
        }
    }
}
```

### Subscriber Tracking

```rust
impl DaemonState {
    /// Called when a TUI subscribes
    pub fn add_tui_subscriber(&mut self) {
        let mut count = self.tui_subscriber_count.lock().unwrap();
        *count += 1;
        tracing::info!("TUI subscribed, total subscribers: {}", *count);
    }

    /// Called when a TUI disconnects
    pub fn remove_tui_subscriber(&mut self) {
        let mut count = self.tui_subscriber_count.lock().unwrap();
        *count = count.saturating_sub(1);
        tracing::info!("TUI unsubscribed, total subscribers: {}", *count);
    }
}
```

### Architecture Alignment

Per [widget-data-flow.md](../architecture/widget-data-flow.md):

**Centralized data flow:**

```text
claude-usage API → daemon (fetch every 3 min) → broadcast to N TUIs
```

**Why centralized:**

- Efficient: 1 API call serves N TUIs
- Rate limit safe: Single fetch point
- Consistent: All TUIs see identical data
- No special cases: Same pattern for all widgets

**Widget contract:** TUI receives all data → populates WidgetContext → passes to
widgets. Widgets never call `claude_usage::get_usage()` directly.
