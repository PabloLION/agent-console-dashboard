# Story: Define API Usage Data Model

**Story ID:** S009.01 **Epic:**
[E009 - API Usage Tracking](../epic/E009-api-usage-tracking.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 3

## Description

As a developer, I want a well-defined data model for tracking API usage, So that
the daemon can store, aggregate, and report consumption metrics consistently.

## Context

API usage tracking is essential for users to monitor their Claude Code
consumption. This story defines the core data structures that will hold usage
metrics including token counts (input/output), estimated costs, and rate limit
information. The data model must support both per-session tracking and
aggregation across all sessions.

This is the foundation story for E009 - all other API usage stories depend on
this data model being defined and implemented correctly. The model must be
flexible enough to handle cases where some data is unavailable (e.g., rate
limits may not always be exposed by Claude Code).

## Implementation Details

### Technical Approach

1. Create `src/api_usage.rs` module for API usage types
2. Define `ApiUsage` struct with all required fields
3. Implement Default trait for empty/initial usage
4. Add serialization support (serde) for IPC transmission
5. Implement aggregation methods for combining multiple sessions
6. Add validation for numeric fields (non-negative values)
7. Include builder pattern for convenient construction

### Files to Modify

- `src/api_usage.rs` (new) - ApiUsage data model and related types
- `src/lib.rs` or `src/main.rs` - Export api_usage module
- `src/daemon/session.rs` - Add ApiUsage field to Session struct

### Dependencies

- [S002.01 - Session Data Model](./S002.01-session-data-model.md) - ApiUsage will be
  embedded in Session

## Acceptance Criteria

- [ ] Given a new session starts, when ApiUsage is initialized, then all token
      counts default to zero
- [ ] Given usage data is received, when stored, then input_tokens and
      output_tokens are tracked separately
- [ ] Given multiple usage updates, when aggregated, then total_tokens equals
      sum of input and output tokens
- [ ] Given cost information is calculated, when stored, then estimated_cost is
      a non-negative float
- [ ] Given rate limit info is available, when stored, then rate_limit_remaining
      and rate_limit_reset are populated
- [ ] Given rate limit info is unavailable, when queried, then Option fields
      return None
- [ ] Given ApiUsage is transmitted over IPC, when serialized/deserialized, then
      all fields are preserved
- [ ] Given a timestamp is recorded, when updated_at is queried, then it
      reflects the last update time

## Testing Requirements

- [ ] Unit test: Default ApiUsage has zero tokens and None for optional fields
- [ ] Unit test: Aggregation correctly sums token counts across multiple
      ApiUsage instances
- [ ] Unit test: Serialization round-trip preserves all field values
- [ ] Unit test: estimated_cost calculation produces accurate results
- [ ] Unit test: Builder pattern creates valid ApiUsage instances
- [ ] Unit test: total_tokens always equals input_tokens + output_tokens

## Out of Scope

- Cost calculation logic (handled in display/widget layer)
- Persistence across daemon restarts
- Historical usage tracking over time periods
- Per-model or per-API-call granularity

## Notes

### Data Model Definition

```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// API usage metrics for a Claude Code session
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ApiUsage {
    /// Claude Code session identifier
    pub session_id: String,

    /// Total input tokens consumed (prompts sent to API)
    pub input_tokens: u64,

    /// Total output tokens generated (responses from API)
    pub output_tokens: u64,

    /// Calculated sum of input and output tokens
    pub total_tokens: u64,

    /// Estimated cost in USD (based on token pricing)
    pub estimated_cost: f64,

    /// Remaining API calls in current rate limit window (if available)
    pub rate_limit_remaining: Option<u32>,

    /// When the rate limit window resets (if available)
    pub rate_limit_reset: Option<DateTime<Utc>>,

    /// When this usage data was last updated
    pub updated_at: DateTime<Utc>,
}
```

### Builder Pattern

```rust
impl ApiUsage {
    pub fn builder() -> ApiUsageBuilder {
        ApiUsageBuilder::default()
    }
}

#[derive(Default)]
pub struct ApiUsageBuilder {
    session_id: String,
    input_tokens: u64,
    output_tokens: u64,
    estimated_cost: Option<f64>,
    rate_limit_remaining: Option<u32>,
    rate_limit_reset: Option<DateTime<Utc>>,
}

impl ApiUsageBuilder {
    pub fn session_id(mut self, id: String) -> Self {
        self.session_id = id;
        self
    }

    pub fn tokens(mut self, input: u64, output: u64) -> Self {
        self.input_tokens = input;
        self.output_tokens = output;
        self
    }

    pub fn rate_limit(mut self, remaining: u32, reset: DateTime<Utc>) -> Self {
        self.rate_limit_remaining = Some(remaining);
        self.rate_limit_reset = Some(reset);
        self
    }

    pub fn build(self) -> ApiUsage {
        let total_tokens = self.input_tokens + self.output_tokens;
        ApiUsage {
            session_id: self.session_id,
            input_tokens: self.input_tokens,
            output_tokens: self.output_tokens,
            total_tokens,
            estimated_cost: self.estimated_cost.unwrap_or(0.0),
            rate_limit_remaining: self.rate_limit_remaining,
            rate_limit_reset: self.rate_limit_reset,
            updated_at: Utc::now(),
        }
    }
}
```

### Aggregation Methods

```rust
impl ApiUsage {
    /// Aggregate usage from multiple sessions
    pub fn aggregate(usages: &[ApiUsage]) -> ApiUsage {
        let input_tokens: u64 = usages.iter().map(|u| u.input_tokens).sum();
        let output_tokens: u64 = usages.iter().map(|u| u.output_tokens).sum();
        let estimated_cost: f64 = usages.iter().map(|u| u.estimated_cost).sum();

        ApiUsage {
            session_id: "aggregate".to_string(),
            input_tokens,
            output_tokens,
            total_tokens: input_tokens + output_tokens,
            estimated_cost,
            rate_limit_remaining: None, // Not meaningful for aggregate
            rate_limit_reset: None,
            updated_at: Utc::now(),
        }
    }

    /// Add tokens to existing usage (for incremental updates)
    pub fn add_tokens(&mut self, input: u64, output: u64) {
        self.input_tokens += input;
        self.output_tokens += output;
        self.total_tokens = self.input_tokens + self.output_tokens;
        self.updated_at = Utc::now();
    }
}
```

### Session Integration

The ApiUsage will be stored as an optional field in the Session struct:

```rust
pub struct Session {
    // ... existing fields ...

    /// API usage metrics for this session
    pub api_usage: Option<ApiUsage>,
}
```

### Considerations

- **Optional fields**: Rate limit info may not be available from all sources
- **Precision**: Token counts are u64 to handle very long sessions
- **Cost accuracy**: estimated_cost is approximate based on published pricing
- **Thread safety**: Consider `Arc<RwLock<ApiUsage>>` if concurrent updates are
  needed
