# Story: Integrate claude-usage Crate

**Story ID:** S009.01 **Epic:**
[E009 - API Usage Tracking](../epic/E009-api-usage-tracking.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 2

## Description

As a developer, I want to integrate the `claude-usage` crate into the TUI
application, So that the dashboard can fetch account-level quota data directly.

## Context

The E009 epic uses the `claude-usage` crate (E011) to fetch account-level 5h and
7d quota utilization. The TUI calls `claude_usage::get_usage()` directly,
bypassing the daemon entirely. This story wires up the crate dependency, adds a
periodic fetch, and stores the result in TUI state for the display story
(S009.03).

No per-session token tracking is needed. Claude Code does not currently expose
per-session token counts via hooks. Account-level quota from E011 provides the
most actionable information.

## Implementation Details

### Technical Approach

1. Add `claude-usage` as a dependency in the TUI crate's `Cargo.toml`
2. Create a usage fetch task that calls `claude_usage::get_usage()` periodically
   (every 5 minutes)
3. Store the fetched `UsageResponse` in TUI application state
4. Handle credential/network errors gracefully (set state to "unavailable")
5. Expose the stored data to the widget rendering layer

### Files to Modify

- `crates/agent-console-dashboard/Cargo.toml` — add `claude-usage` dependency
- `crates/agent-console-dashboard/src/tui/state.rs` (new) — add usage data to
  TUI state
- `crates/agent-console-dashboard/src/tui/fetch.rs` (new) — periodic usage fetch
  task

### Dependencies

- [E011 - Claude Usage Crate](../epic/E011-claude-usage-crate.md) — provides
  `get_usage()` API
- [S004.01 - Ratatui Application Scaffold](./S004.01-ratatui-application-scaffold.md)
  — TUI must exist

## Acceptance Criteria

- [ ] Given the TUI starts, when 5 minutes elapse, then
      `claude_usage::get_usage()` is called
- [ ] Given a successful API response, when stored, then 5h and 7d utilization
      percentages are available in TUI state
- [ ] Given a credential error, when fetch fails, then state shows "unavailable"
      without crashing
- [ ] Given a network error, when fetch fails, then previous data is retained and
      error is logged
- [ ] Given the TUI is running, when multiple fetches succeed, then state
      reflects the latest response

## Testing Requirements

- [ ] Unit test: TUI state stores and retrieves usage data correctly
- [ ] Unit test: Error handling sets state to unavailable
- [ ] Unit test: Fetch interval respects configuration
- [ ] Integration test: `claude_usage::get_usage()` call succeeds with valid
      credentials

## Out of Scope

- Per-session token tracking (no data source available)
- Daemon-side usage aggregation
- Cost estimates
- IPC commands for usage data
- Display formatting (handled in S009.03)

## Notes

### TUI State Extension

```rust
use claude_usage::types::UsageResponse;

pub struct TuiState {
    // ... existing fields ...

    /// Account-level usage data from claude-usage crate
    pub usage: Option<UsageResponse>,

    /// Whether the last usage fetch failed
    pub usage_unavailable: bool,
}
```

### Periodic Fetch

```rust
use claude_usage::get_usage;

/// Fetch usage data periodically (every 5 minutes)
async fn fetch_usage_loop(state: Arc<Mutex<TuiState>>) {
    let interval = Duration::from_secs(300);
    loop {
        match get_usage() {
            Ok(data) => {
                let mut s = state.lock().unwrap();
                s.usage = Some(data);
                s.usage_unavailable = false;
            }
            Err(e) => {
                tracing::warn!("Usage fetch failed: {}", e);
                let mut s = state.lock().unwrap();
                s.usage_unavailable = true;
            }
        }
        tokio::time::sleep(interval).await;
    }
}
```
