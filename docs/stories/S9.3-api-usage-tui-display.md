# Story: Display API Usage in TUI

**Story ID:** S9.3 **Epic:**
[E009 - API Usage Tracking](../epic/E009-api-usage-tracking.md) **Status:**
Draft **Priority:** P2 **Estimated Points:** 3

## Description

As a user, I want to see API usage metrics displayed in the TUI dashboard, So
that I can monitor my token consumption and estimated costs at a glance.

## Context

With the API usage data model (S9.1) and IPC commands (S9.2) in place, the TUI
dashboard needs to display this information to users. This story focuses on
integrating usage data into the dashboard display, complementing the api-usage
widget defined in S5.4 (E005 Widget System).

The display should show both session-specific usage (when a session is selected)
and aggregate usage across all sessions. The information should be updated in
real-time as new usage data arrives via the SUBSCRIBE mechanism.

## Implementation Details

### Technical Approach

1. Extend TUI client to subscribe to usage updates
2. Add usage data to the WidgetContext for widget rendering
3. Display session-specific usage in the session detail view
4. Display aggregate usage in the dashboard header/footer
5. Implement real-time updates when usage changes
6. Handle cases where usage data is unavailable gracefully
7. Format numbers for readability (1.2k instead of 1200)

### Files to Modify

- `src/tui/app.rs` - Add usage data to application state
- `src/tui/client.rs` - Subscribe to usage updates from daemon
- `src/tui/views/session_detail.rs` - Display per-session usage
- `src/tui/views/dashboard.rs` - Display aggregate usage
- `src/widgets/context.rs` - Add api_usage to WidgetContext

### Dependencies

- [S4.1 - Ratatui Application Scaffold](./S4.1-ratatui-application-scaffold.md) -
  TUI application base
- [S4.4 - Session Selection and Detail View](./S4.4-session-selection-detail-view.md)
  \- Session detail view
- [S5.4 - API Usage Widget](./S5.4-api-usage-widget.md) - Widget implementation
  for rendering usage
- [S9.1 - API Usage Data Model](./S9.1-api-usage-data-model.md) - ApiUsage
  struct
- [S9.2 - API_USAGE Command](./S9.2-api-usage-command.md) - IPC commands for
  querying usage

## Acceptance Criteria

- [ ] Given a session is selected, when usage data exists, then session-specific
      tokens and cost are displayed
- [ ] Given a session is selected, when no usage data exists, then "Usage: --"
      placeholder is shown
- [ ] Given the dashboard is visible, when aggregate usage is available, then
      total tokens across all sessions are shown
- [ ] Given usage data is updated, when the daemon reports new values, then
      display updates within 1 second
- [ ] Given high token usage, when displayed, then warning colors (yellow/red)
      indicate elevated consumption
- [ ] Given rate limit info is available, when displayed, then remaining calls
      and reset time are shown
- [ ] Given terminal width is narrow, when rendering, then compact format is
      used

## Testing Requirements

- [ ] Unit test: Session detail view renders usage when available
- [ ] Unit test: Session detail view renders placeholder when usage unavailable
- [ ] Unit test: Dashboard renders aggregate usage correctly
- [ ] Unit test: Number formatting produces human-readable output (1.2k, 5.3M)
- [ ] Unit test: Color thresholds apply correctly for usage levels
- [ ] Integration test: Usage updates from daemon appear in TUI
- [ ] Integration test: Selecting different sessions shows correct per-session
      usage

## Out of Scope

- Usage graphs or charts over time
- Detailed cost breakdown by model
- Usage alerts or notifications
- Export or copy usage data
- Usage comparison between sessions

## Notes

### Display Layout

**Session Detail View (selected session):**

```text
┌─ Session: abc123 ─────────────────────────────────┐
│ Status: Working                                    │
│ Directory: ~/projects/myapp                        │
│ Started: 2024-01-15 10:30:00                       │
│                                                    │
│ API Usage:                                         │
│   Tokens: 12.3k in / 8.1k out (20.4k total)       │
│   Estimated Cost: $0.42                            │
│   Rate Limit: 98/100 remaining (resets in 5m)      │
└────────────────────────────────────────────────────┘
```

**Dashboard Footer (aggregate):**

```text
───────────────────────────────────────────────────────
Sessions: 3 active │ Total: 38.4k tokens │ Cost: ~$1.24
───────────────────────────────────────────────────────
```

### TUI State Extension

```rust
pub struct TuiState {
    // ... existing fields ...

    /// API usage for the currently selected session
    pub selected_session_usage: Option<ApiUsage>,

    /// Aggregate API usage across all sessions
    pub aggregate_usage: Option<ApiUsage>,
}
```

### Widget Context Extension

```rust
pub struct WidgetContext<'a> {
    // ... existing fields ...

    /// API usage data for rendering (session-specific or aggregate)
    pub api_usage: Option<&'a ApiUsage>,
}
```

### Real-Time Update Flow

1. TUI client subscribes to daemon on startup
2. Daemon sends usage updates when SET_USAGE is called
3. TUI receives update event with session_id and new usage
4. TUI state is updated with new usage data
5. Next render cycle displays updated values

```rust
impl TuiClient {
    /// Handle incoming usage update from daemon
    fn handle_usage_update(&mut self, session_id: &str, usage: ApiUsage) {
        // Update session-specific usage if this is the selected session
        if self.state.selected_session == Some(session_id.to_string()) {
            self.state.selected_session_usage = Some(usage.clone());
        }

        // Update aggregate usage
        self.refresh_aggregate_usage();
    }

    /// Fetch aggregate usage from daemon
    fn refresh_aggregate_usage(&mut self) {
        // Send API_USAGE_ALL command and update state with response
        let response = self.send_command("API_USAGE_ALL");
        if let Ok(aggregate) = serde_json::from_str(&response) {
            self.state.aggregate_usage = Some(aggregate);
        }
    }
}
```

### Number Formatting

```rust
/// Format token count for display
fn format_tokens(count: u64) -> String {
    if count < 1000 {
        format!("{}", count)
    } else if count < 1_000_000 {
        format!("{:.1}k", count as f64 / 1000.0)
    } else {
        format!("{:.1}M", count as f64 / 1_000_000.0)
    }
}

/// Format cost for display
fn format_cost(cost: f64) -> String {
    if cost < 0.01 {
        format!("${:.4}", cost) // Show more precision for small amounts
    } else {
        format!("${:.2}", cost)
    }
}
```

### Rate Limit Display

```rust
/// Format rate limit for display
fn format_rate_limit(remaining: Option<u32>, reset: Option<DateTime<Utc>>) -> String {
    match (remaining, reset) {
        (Some(remaining), Some(reset)) => {
            let duration = reset - Utc::now();
            let minutes = duration.num_minutes();
            format!("{} remaining (resets in {}m)", remaining, minutes)
        }
        (Some(remaining), None) => {
            format!("{} remaining", remaining)
        }
        _ => "Rate limit: --".to_string()
    }
}
```

### Color Thresholds

| Metric               | Green | Yellow     | Red    |
| -------------------- | ----- | ---------- | ------ |
| Session tokens       | < 50k | 50k - 100k | > 100k |
| Session cost         | < $1  | $1 - $5    | > $5   |
| Aggregate cost       | < $5  | $5 - $20   | > $20  |
| Rate limit remaining | > 50% | 10-50%     | < 10%  |

These thresholds can be made configurable in a future story.

### Graceful Degradation

When usage data is unavailable:

- Display "Usage: --" placeholder
- Don't show usage section at all if configured to hide when empty
- Log a debug message but don't show errors to user
- Continue normal operation with other widgets

### Performance Considerations

- Cache aggregate usage to avoid recalculating on every render
- Throttle usage update events (max 1 per second to TUI)
- Use incremental updates rather than full refresh when possible
