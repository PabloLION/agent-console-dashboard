# Story: Define IPC Message Protocol

**Story ID:** S3.1 **Epic:**
[E003 - IPC Protocol & Client](../epic/E003-ipc-protocol-and-client.md)
**Status:** Draft **Priority:** P1 **Estimated Points:** 5

## Description

As a developer, I want to define a text-based IPC message protocol, So that
hooks, clients, and the daemon can communicate reliably over Unix sockets.

## Context

The IPC protocol is the communication layer between all components of the Agent
Console system. Hooks use it to report session status changes, CLI clients use
it for queries and commands, and the TUI dashboard uses it for real-time
subscriptions. The protocol must be simple enough for easy debugging while being
robust enough for reliable communication.

A text-based protocol was chosen over binary formats because:

- Human-readable for easy debugging (can use `nc` or `socat` to test)
- Simple parsing (line-delimited messages)
- No serialization library required for basic commands
- JSON used only for complex data structures

## Implementation Details

### Technical Approach

1. Create `src/daemon/protocol.rs` for message types and parsing
2. Define `Command` enum for client-to-daemon messages
3. Define `Response` enum for daemon-to-client messages
4. Implement `FromStr` for parsing incoming text commands
5. Implement `Display` for serializing responses
6. Handle edge cases (malformed messages, unknown commands)

### Message Format

```text
# Commands (client -> daemon)
SET <session> <status> [metadata_json]
RM <session>
LIST
SUBSCRIBE
RESURRECT <session>
API_USAGE <session> <tokens_json>

# Responses (daemon -> client)
OK
OK <data_json>
ERR <message>
STATE <json>
UPDATE <session> <status> <elapsed_seconds>
```

### Files to Modify

- `src/daemon/protocol.rs` - Create new file for protocol types
- `src/daemon/mod.rs` - Export protocol module
- `src/lib.rs` - Add shared protocol types if needed

### Dependencies

- [S1.2 - Unix Socket Server](./S1.2-unix-socket-server.md) - Protocol messages
  flow over the socket
- [S2.1 - Session Data Model](./S2.1-session-data-model.md) - Protocol
  references session status types

## Acceptance Criteria

- [ ] Given a valid SET command string, when parsed, then returns `Command::Set`
      with correct session, status, and optional metadata
- [ ] Given a valid LIST command, when parsed, then returns `Command::List`
- [ ] Given a valid SUBSCRIBE command, when parsed, then returns
      `Command::Subscribe`
- [ ] Given a malformed command, when parsed, then returns an appropriate parse
      error
- [ ] Given a `Response::Ok`, when serialized, then produces "OK\n"
- [ ] Given a `Response::Error`, when serialized, then produces
      `ERR <message>\n`
- [ ] Given any message, then it is newline-delimited for stream framing

## Testing Requirements

- [ ] Unit test: Parse SET command with all valid status values (working,
      attention, question)
- [ ] Unit test: Parse SET command with optional JSON metadata
- [ ] Unit test: Parse all command types (SET, RM, LIST, SUBSCRIBE, RESURRECT,
      API_USAGE)
- [ ] Unit test: Parse errors for malformed commands
- [ ] Unit test: Response serialization round-trip
- [ ] Unit test: Handle edge cases (empty strings, extra whitespace)

## Out of Scope

- Actual command execution (handled by individual command stories)
- Socket transport layer (S1.2)
- TLS/encryption (not needed for local Unix socket)
- Protocol versioning (future consideration)

## Notes

### Command Enum Design

```rust
pub enum Command {
    Set { session: String, status: Status, metadata: Option<serde_json::Value> },
    Remove { session: String },
    List,
    Subscribe,
    Resurrect { session: String },
    ApiUsage { session: String, tokens: TokenUsage },
}

pub enum Response {
    Ok,
    OkData(serde_json::Value),
    Error(String),
    State(serde_json::Value),
    Update { session: String, status: Status, elapsed_secs: u64 },
}
```

### Key Dependencies

| Crate      | Purpose                                     |
| ---------- | ------------------------------------------- |
| serde_json | JSON parsing for metadata/complex responses |

### Design Decisions

- Newline-delimited for simple framing (no length prefixes needed)
- Status as simple text (working/attention/question) not JSON
- JSON only for complex nested data (metadata, state dumps)
- Error messages are human-readable strings
