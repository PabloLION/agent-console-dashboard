# Story: napi-rs Bindings for npm

**Story ID:** S011.07 **Epic:**
[E011 - Claude Usage Crate](../epic/E011-claude-usage-crate.md) **Status:**
Deferred **Priority:** P2 **Estimated Points:** 5

## Description

As a Node.js developer, I want to use `claude-usage` from npm, So that I can fetch Claude usage data in my JavaScript/TypeScript projects.

## Context

napi-rs enables creating native Node.js addons from Rust code. This provides better performance than WASM and full access to system APIs (Keychain, filesystem). The npm package would mirror the Rust API, making the crate accessible to the JavaScript ecosystem.

This story is deferred to v2+ per project priorities. The Rust crate provides the core functionality; npm bindings are a nice-to-have for broader reach but not essential for the primary use case (Rust daemon consuming the crate).

## Implementation Details

### Technical Approach

1. Add napi-rs dependencies to `claude-usage` crate
2. Create napi bindings for `get_usage()` and types
3. Configure napi build for multiple platforms (macOS arm64/x64, Linux x64/arm64)
4. Set up npm package structure with platform-specific binaries
5. Publish to npm as `claude-usage`

### Package Structure

```text
crates/claude-usage/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   └── napi.rs        # napi bindings (feature-gated)
├── npm/
│   ├── package.json
│   ├── index.js
│   ├── index.d.ts
│   └── darwin-arm64/
│       └── claude-usage.darwin-arm64.node
```

### Files to Create

- `crates/claude-usage/src/napi.rs` - napi bindings (feature-gated)
- `crates/claude-usage/npm/package.json` - npm package manifest
- `crates/claude-usage/npm/index.js` - JS entry point
- `crates/claude-usage/npm/index.d.ts` - TypeScript definitions

### Files to Modify

- `crates/claude-usage/Cargo.toml` - Add napi dependencies under feature flag

### Dependencies

- S011.06: Rust crate must be published to crates.io

## Acceptance Criteria

- [ ] Given napi build, when compiled on macOS arm64, then native addon `.node` file is produced
- [ ] Given napi build, when compiled on Linux x86_64, then native addon `.node` file is produced
- [ ] Given npm package installed, when `require('claude-usage')` is called, then module loads
- [ ] Given `getUsage()` called in Node.js, when credentials exist, then usage data is returned
- [ ] Given TypeScript project, when importing, then TypeScript types are available

## Testing Requirements

- [ ] Unit test: napi bindings compile
- [ ] Integration test: Node.js can call `getUsage()`
- [ ] Integration test: TypeScript types match runtime behavior
- [ ] Manual test: Works on macOS and Linux

## Out of Scope

- Browser/WASM support (napi-rs is Node.js only)
- Deno support
- Bun support (may work but not officially tested)

## Notes

### Cargo.toml Additions

```toml
[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = []
napi = ["dep:napi", "dep:napi-derive"]

[dependencies]
napi = { version = "2", optional = true }
napi-derive = { version = "2", optional = true }

[build-dependencies]
napi-build = { version = "2", optional = true }
```

### napi Bindings

```rust
// src/napi.rs (only compiled with napi feature)

#[cfg(feature = "napi")]
mod napi_bindings {
    use napi_derive::napi;
    use crate::{get_usage, UsageData};

    #[napi(object)]
    pub struct JsUsagePeriod {
        pub utilization: f64,
        pub resets_at: String,
    }

    #[napi(object)]
    pub struct JsUsageData {
        pub five_hour: JsUsagePeriod,
        pub seven_day: JsUsagePeriod,
    }

    #[napi]
    pub fn get_usage_sync() -> napi::Result<JsUsageData> {
        let usage = get_usage()
            .map_err(|e| napi::Error::from_reason(e.to_string()))?;

        Ok(JsUsageData {
            five_hour: JsUsagePeriod {
                utilization: usage.five_hour.utilization,
                resets_at: usage.five_hour.resets_at.to_rfc3339(),
            },
            seven_day: JsUsagePeriod {
                utilization: usage.seven_day.utilization,
                resets_at: usage.seven_day.resets_at.to_rfc3339(),
            },
        })
    }
}
```

### package.json

```json
{
  "name": "claude-usage",
  "version": "0.1.0",
  "description": "Fetch Claude API usage data from Anthropic",
  "main": "index.js",
  "types": "index.d.ts",
  "napi": {
    "name": "claude-usage",
    "triples": {
      "defaults": true,
      "additional": ["aarch64-apple-darwin"]
    }
  },
  "scripts": {
    "build": "napi build --platform --release",
    "prepublishOnly": "napi prepublish -t npm"
  },
  "keywords": ["claude", "anthropic", "usage", "api"],
  "license": "MIT OR Apache-2.0"
}
```

### TypeScript Definitions

```typescript
// index.d.ts
export interface UsagePeriod {
  utilization: number;
  resetsAt: string;
}

export interface UsageData {
  fiveHour: UsagePeriod;
  sevenDay: UsagePeriod;
}

export function getUsageSync(): UsageData;
```

### Build Matrix

| Platform | Architecture | Target |
|----------|-------------|--------|
| macOS | arm64 | aarch64-apple-darwin |
| macOS | x64 | x86_64-apple-darwin |
| Linux | x64 | x86_64-unknown-linux-gnu |
| Linux | arm64 | aarch64-unknown-linux-gnu |

### Why Deferred

Deferred to v2+ because:
- Primary consumers are Rust (daemon, tools)
- Publishing to npm requires CI/CD setup for multi-platform builds
- Maintenance burden for platform-specific binaries
- Can be added later without breaking changes to Rust API
