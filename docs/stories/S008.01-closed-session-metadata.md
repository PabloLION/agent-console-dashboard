# Story: Store Session Metadata for Closed Sessions

**Story ID:** S008.01 **Epic:**
[E008 - Session Resurrection](../epic/E008-session-resurrection.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 3

## Description

As a user, I want the daemon to retain metadata when Claude Code sessions close,
So that I can later identify and resurrect previous sessions.

## Context

Session resurrection requires knowing which sessions existed, their working
directories, and session identifiers even after the sessions have closed.
Currently, when a Claude Code session closes (detected via the Stop hook), the
session data is discarded. This story implements the retention of session
metadata for closed sessions, enabling the resurrection workflow.

The retained metadata must include enough information to invoke
`claude --resume <session-id>` and to help users identify which session they
want to resurrect. Metadata should be stored in memory (not persisted across
daemon restarts) consistent with the project's ephemeral state philosophy.

Per
[D8 decision](../architecture/2026-01-31-discussion-decisions.md#d8-session-identification---json-stdin-session_id),
Claude Code exposes `session_id` in JSON stdin to ALL hook types. Hook scripts
parse stdin JSON to extract `session_id` â€” the `basename "$PWD"` pattern in
older examples is stale.

## Implementation Details

### Technical Approach

1. Extend the session data model to include a "closed" state
2. When Stop hook fires, transition session to "closed" instead of removing it
3. Add a `closed_at` timestamp field to track when session closed
4. Add a `resumable` flag to indicate if session can be resumed (user-settable,
   not auto-detected)
5. Implement cleanup logic to remove very old closed sessions (configurable
   limit)
6. Store closed sessions in a separate collection for efficient querying

### Files to Modify

- `crates/agent-console-dashboard/src/daemon/session.rs` - Add closed session
  state and metadata fields
- `crates/agent-console-dashboard/src/daemon/store.rs` - Add closed sessions
  storage and retrieval methods
- `crates/agent-console-dashboard/src/hooks/stop.rs` - Modify to transition
  session to closed state instead of removing
- `crates/agent-console-dashboard/src/ipc/protocol.rs` - Add LIST_CLOSED command
  support

### Dependencies

- [S002.01 - Session Data Model](./S002.01-session-data-model.md) - Defines base
  session structure
- [S002.02 - Session Status Transitions](./S002.02-session-status-transitions.md)
  \- Defines state machine
- [S002.04 - Session Lifecycle Events](./S002.04-session-lifecycle-events.md) -
  Handles session close events
- [S006.01 - Stop Hook Script](./S006.01-stop-hook-script.md) - Detects when
  session closes

## Acceptance Criteria

- [ ] Given an active session, when the Stop hook fires, then session
      transitions to "closed" state with metadata retained
- [ ] Given a closed session, when metadata is queried, then working_dir,
      session_id, and closed_at are available
- [ ] Given multiple closed sessions, when listed, then they are returned sorted
      by closed_at (most recent first)
- [ ] Given closed sessions exceed the retention limit (default: 20), when a new
      session closes, then the oldest closed session is removed
- [ ] Given a session marked as non-resumable by user, when closed, then
      resumable flag is set to false
- [ ] Given the daemon restarts, when started, then all closed session metadata
      is cleared (ephemeral)
- [ ] Given a session that closes normally, when metadata is stored, then
      original working directory is preserved
- [ ] Given multiple closed sessions per directory, when listed, then all
      sessions are shown individually per
      [Q19 decision](../epic/E008-session-resurrection.md#multiple-sessions-per-directory)

## Testing Requirements

- [ ] Unit test: Session transitions to closed state on stop event
- [ ] Unit test: Closed session metadata includes all required fields
- [ ] Unit test: Closed sessions are stored separately from active sessions
- [ ] Unit test: LIST_CLOSED returns closed sessions sorted by time
- [ ] Unit test: Old closed sessions are cleaned up after retention limit
- [ ] Integration test: Stop hook triggers closed session storage
- [ ] Integration test: Closed session metadata survives active session list
      queries
- [ ] Unit test: Session ID extraction from JSON stdin (D8)

## Out of Scope

- Persisting closed session metadata across daemon restarts
- Auto-detecting context limit exceeded (resumability is user-settable flag)
- Actually resuming the session (handled in S008.02, S010.03)
- Zellij pane management for resurrection

## Notes

### Closed Session Data Model

```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// Metadata for a closed session available for resurrection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClosedSession {
    /// Unique session identifier from Claude Code (extracted from JSON stdin)
    pub session_id: String,
    /// Working directory where session was running
    pub working_dir: PathBuf,
    /// When the session was first started
    pub started_at: DateTime<Utc>,
    /// When the session was closed
    pub closed_at: DateTime<Utc>,
    /// Whether the session can be resumed (user-settable, not auto-detected)
    pub resumable: bool,
    /// Optional reason why session is not resumable
    pub not_resumable_reason: Option<String>,
    /// Last known status before closing
    pub last_status: SessionStatus,
}
```

### Storage Strategy

```rust
use std::collections::{HashMap, VecDeque};

pub struct SessionStore {
    /// Active sessions indexed by session_id
    active: HashMap<String, Session>,
    /// Closed sessions available for resurrection
    closed: VecDeque<ClosedSession>,
    /// Maximum count of closed sessions to retain
    max_closed_sessions: usize,
}

impl SessionStore {
    /// Move a session from active to closed
    pub fn close_session(&mut self, session_id: &str) -> Option<ClosedSession> {
        if let Some(session) = self.active.remove(session_id) {
            let closed = ClosedSession {
                session_id: session.id.clone(),
                working_dir: session.working_dir.clone(),
                started_at: session.started_at,
                closed_at: Utc::now(),
                resumable: true, // Assume resumable unless user flags otherwise
                not_resumable_reason: None,
                last_status: session.status,
            };

            // Add to front (most recent first)
            self.closed.push_front(closed.clone());

            // Enforce retention limit
            while self.closed.len() > self.max_closed_sessions {
                self.closed.pop_back();
            }

            Some(closed)
        } else {
            None
        }
    }

    /// List all closed sessions available for resurrection
    pub fn list_closed(&self) -> Vec<&ClosedSession> {
        self.closed.iter().collect()
    }

    /// Get a specific closed session by ID
    pub fn get_closed(&self, session_id: &str) -> Option<&ClosedSession> {
        self.closed.iter().find(|s| s.session_id == session_id)
    }
}
```

### Session ID Extraction from JSON stdin

Per
[D8 decision](../architecture/2026-01-31-discussion-decisions.md#d8-session-identification---json-stdin-session_id):

```bash
# In Stop hook script
INPUT=$(cat)
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id')
agent-console close "$SESSION_ID"
```

The `basename "$PWD"` pattern in some older epic examples is stale and must not
be used.

### Configuration Options

The count of closed sessions to retain should be configurable:

```toml
[daemon]
# Maximum count of closed sessions to retain for resurrection
max_closed_sessions = 20
```

### Multiple Sessions Per Directory

Per
[Q19 decision](../epic/E008-session-resurrection.md#multiple-sessions-per-directory),
v0/v1 relies on Claude Code's built-in session picker when multiple sessions
exist in the same directory. Display session count per directory so users know
disambiguation will be needed. v2+ may use `claude --resume <session-id>` for
precise resurrection.

### Considerations

- **Memory usage**: Each closed session is small (a few hundred bytes), so
  retaining 20-50 sessions is negligible
- **Ordering**: Most recent closed sessions are likely most wanted, so sort by
  closed_at descending
- **Deduplication**: If a session ID appears multiple times (edge case), keep
  only the most recent
