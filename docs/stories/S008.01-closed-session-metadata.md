# Story: Store Session Metadata for Closed Sessions

**Story ID:** S008.01 **Epic:**
[E008 - Session Resurrection](../epic/E008-session-resurrection.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 3

## Description

As a user, I want the dashboard to retain metadata when Claude Code sessions
close, So that I can later identify and resurrect previous sessions.

## Context

Session resurrection requires knowing which sessions existed, their working
directories, and session identifiers even after the sessions have closed.
Currently, when a Claude Code session closes (detected via the Stop hook), the
session data is discarded. This story implements the retention of session
metadata for closed sessions, enabling the resurrection workflow.

The retained metadata must include enough information to invoke
`claude --resume <session-id>` and to help users identify which session they
want to resurrect. Metadata should be stored in memory (not persisted across
daemon restarts) consistent with the project's ephemeral state philosophy.

## Implementation Details

### Technical Approach

1. Extend the session data model to include a "closed" state
2. When Stop hook fires, transition session to "closed" instead of removing it
3. Add a `closed_at` timestamp field to track when session closed
4. Add a `resumable` flag to indicate if session can be resumed
5. Implement cleanup logic to remove very old closed sessions (configurable
   limit)
6. Store closed sessions in a separate collection for efficient querying

### Files to Modify

- `crates/agent-console-dashboard/src/daemon/session.rs` - Add closed session state and metadata fields
- `crates/agent-console-dashboard/src/daemon/store.rs` - Add closed sessions storage and retrieval methods
- `crates/agent-console-dashboard/src/hooks/stop.rs` - Modify to transition session to closed state instead of
  removing
- `crates/agent-console-dashboard/src/ipc/protocol.rs` - Add LIST_CLOSED command support

### Dependencies

- [S002.01 - Session Data Model](./S002.01-session-data-model.md) - Defines base
  session structure
- [S002.02 - Session Status Transitions](./S002.02-session-status-transitions.md) -
  Defines state machine
- [S002.04 - Session Lifecycle Events](./S002.04-session-lifecycle-events.md) -
  Handles session close events
- [S006.01 - Stop Hook Script](./S006.01-stop-hook-script.md) - Detects when session
  closes

## Acceptance Criteria

- [ ] Given an active session, when the Stop hook fires, then session
      transitions to "closed" state with metadata retained
- [ ] Given a closed session, when metadata is queried, then working_dir,
      session_id, and closed_at are available
- [ ] Given multiple closed sessions, when listed, then they are returned sorted
      by closed_at (most recent first)
- [ ] Given a closed session older than the retention limit, when cleanup runs,
      then it is removed from storage
- [ ] Given a session with exceeded context limit, when marked as closed, then
      resumable flag is set to false
- [ ] Given the daemon restarts, when started, then all closed session metadata
      is cleared (ephemeral)
- [ ] Given a session that closes normally, when metadata is stored, then
      original working directory is preserved

## Testing Requirements

- [ ] Unit test: Session transitions to closed state on stop event
- [ ] Unit test: Closed session metadata includes all required fields
- [ ] Unit test: Closed sessions are stored separately from active sessions
- [ ] Unit test: LIST_CLOSED returns closed sessions sorted by time
- [ ] Unit test: Old closed sessions are cleaned up after retention period
- [ ] Integration test: Stop hook triggers closed session storage
- [ ] Integration test: Closed session metadata survives active session list
      queries

## Out of Scope

- Persisting closed session metadata across daemon restarts
- Detecting context limit exceeded (handled in
  [S010.03](./S010.03-claude-resume-in-terminal.md))
- Actually resuming the session (handled in S008.02,
  [S010.03](./S010.03-claude-resume-in-terminal.md))
- Zellij pane management for resurrection

## Notes

### Closed Session Data Model

```rust
/// Metadata for a closed session available for resurrection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClosedSession {
    /// Unique session identifier from Claude Code
    pub session_id: String,
    /// Working directory where session was running
    pub working_dir: PathBuf,
    /// When the session was first started
    pub started_at: DateTime<Utc>,
    /// When the session was closed
    pub closed_at: DateTime<Utc>,
    /// Whether the session can be resumed (context not exceeded)
    pub resumable: bool,
    /// Optional reason why session is not resumable
    pub not_resumable_reason: Option<String>,
    /// Last known status before closing
    pub last_status: SessionStatus,
}
```

### Storage Strategy

```rust
pub struct SessionStore {
    /// Active sessions indexed by session_id
    active: HashMap<String, Session>,
    /// Closed sessions available for resurrection
    closed: VecDeque<ClosedSession>,
    /// Maximum number of closed sessions to retain
    max_closed_sessions: usize,
}

impl SessionStore {
    /// Move a session from active to closed
    pub fn close_session(&mut self, session_id: &str) -> Option<ClosedSession> {
        if let Some(session) = self.active.remove(session_id) {
            let closed = ClosedSession {
                session_id: session.id.clone(),
                working_dir: session.working_dir.clone(),
                started_at: session.started_at,
                closed_at: Utc::now(),
                resumable: true, // Assume resumable until proven otherwise
                not_resumable_reason: None,
                last_status: session.status,
            };

            // Add to front (most recent first)
            self.closed.push_front(closed.clone());

            // Enforce retention limit
            while self.closed.len() > self.max_closed_sessions {
                self.closed.pop_back();
            }

            Some(closed)
        } else {
            None
        }
    }

    /// List all closed sessions available for resurrection
    pub fn list_closed(&self) -> Vec<&ClosedSession> {
        self.closed.iter().collect()
    }

    /// Get a specific closed session by ID
    pub fn get_closed(&self, session_id: &str) -> Option<&ClosedSession> {
        self.closed.iter().find(|s| s.session_id == session_id)
    }
}
```

### Configuration Options

The number of closed sessions to retain should be configurable:

```toml
[daemon]
# Maximum number of closed sessions to retain for resurrection
max_closed_sessions = 20
```

### Considerations

- **Memory usage**: Each closed session is small (a few hundred bytes), so
  retaining 20-50 sessions is negligible
- **Ordering**: Most recent closed sessions are likely most wanted, so sort by
  closed_at descending
- **Deduplication**: If a session ID appears multiple times (edge case), keep
  only the most recent
