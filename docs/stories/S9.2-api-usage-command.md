# Story: Implement API_USAGE Command

**Story ID:** S9.2 **Epic:**
[E009 - API Usage Tracking](../epic/E009-api-usage-tracking.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 5

## Description

As a user or client application, I want IPC commands to query and update API
usage data, So that I can monitor consumption and hooks can report usage
metrics.

## Context

The API usage tracking system requires IPC commands to function. Hooks from
Claude Code need a way to report usage data to the daemon, and the TUI client
needs to query this data for display. This story implements the IPC protocol
extensions for API usage: API_USAGE (query single session), API_USAGE_ALL (query
aggregate), and SET_USAGE (update metrics).

These commands follow the same patterns established in E003 for other IPC
commands like SET, LIST, and SUBSCRIBE. The commands must handle edge cases like
querying non-existent sessions and malformed usage data.

## Implementation Details

### Technical Approach

1. Extend IPC protocol with three new commands:
   - `API_USAGE <session-id>` - Query usage for specific session
   - `API_USAGE_ALL` - Query aggregated usage across all sessions
   - `SET_USAGE <session-id> <usage-json>` - Update usage for a session
2. Add command parsing for new commands in protocol handler
3. Implement command handlers in daemon
4. Add usage storage and retrieval methods to session store
5. Return JSON-formatted responses for usage queries
6. Handle error cases with appropriate error responses

### Files to Modify

- `src/ipc/protocol.rs` - Add API_USAGE, API_USAGE_ALL, SET_USAGE command
  definitions
- `src/ipc/commands.rs` - Implement command handlers
- `src/daemon/store.rs` - Add usage storage and retrieval methods
- `src/daemon/session.rs` - Integrate ApiUsage with session

### Dependencies

- [S3.1 - IPC Message Protocol](./S3.1-ipc-message-protocol.md) - Base protocol
  definition
- [S3.2 - SET Command](./S3.2-set-command.md) - Pattern for command
  implementation
- [S9.1 - API Usage Data Model](./S9.1-api-usage-data-model.md) - ApiUsage
  struct definition

## Acceptance Criteria

- [ ] Given a valid session_id, when API_USAGE is called, then usage data is
      returned as JSON
- [ ] Given an invalid session_id, when API_USAGE is called, then ERROR response
      with "session not found" is returned
- [ ] Given multiple sessions with usage data, when API_USAGE_ALL is called,
      then aggregated totals are returned
- [ ] Given no sessions exist, when API_USAGE_ALL is called, then zero-value
      usage is returned
- [ ] Given valid usage JSON, when SET_USAGE is called, then session usage is
      updated and OK is returned
- [ ] Given malformed usage JSON, when SET_USAGE is called, then ERROR response
      with parse error is returned
- [ ] Given non-existent session, when SET_USAGE is called, then ERROR response
      with "session not found" is returned
- [ ] Given cumulative SET_USAGE calls, when usage is queried, then totals
      reflect all updates

## Testing Requirements

- [ ] Unit test: API_USAGE returns correct JSON for existing session
- [ ] Unit test: API_USAGE returns error for non-existent session
- [ ] Unit test: API_USAGE_ALL aggregates all session usages correctly
- [ ] Unit test: API_USAGE_ALL returns zero-usage when no sessions exist
- [ ] Unit test: SET_USAGE parses valid JSON and updates session
- [ ] Unit test: SET_USAGE rejects malformed JSON with descriptive error
- [ ] Integration test: Full round-trip SET_USAGE then API_USAGE returns updated
      values
- [ ] Integration test: Hook script can call SET_USAGE successfully

## Out of Scope

- Real-time usage push via SUBSCRIBE (future enhancement)
- Usage history queries (only current totals)
- Usage reset or clear commands
- Authentication or authorization for commands

## Notes

### Command Protocol

```text
# Query usage for a specific session
API_USAGE <session-id>

# Response (success):
{
  "session_id": "abc123",
  "input_tokens": 1500,
  "output_tokens": 2300,
  "total_tokens": 3800,
  "estimated_cost": 0.042,
  "rate_limit_remaining": 98,
  "rate_limit_reset": "2024-01-15T12:30:00Z",
  "updated_at": "2024-01-15T12:00:00Z"
}

# Response (error):
ERROR session not found: abc123
```

```text
# Query aggregated usage across all sessions
API_USAGE_ALL

# Response:
{
  "session_count": 3,
  "input_tokens": 15000,
  "output_tokens": 23000,
  "total_tokens": 38000,
  "estimated_cost": 0.42,
  "sessions": [
    {"session_id": "abc123", "total_tokens": 12000},
    {"session_id": "def456", "total_tokens": 18000},
    {"session_id": "ghi789", "total_tokens": 8000}
  ]
}
```

```text
# Update usage for a session (called by hooks)
SET_USAGE <session-id> {"input_tokens": 500, "output_tokens": 800}

# Response (success):
OK

# Response (error):
ERROR invalid JSON: expected field 'input_tokens'
ERROR session not found: xyz999
```

### Command Implementation

```rust
use crate::api_usage::ApiUsage;
use crate::ipc::{Command, Response};

pub enum ApiUsageCommand {
    /// Query usage for a specific session
    Query { session_id: String },
    /// Query aggregated usage across all sessions
    QueryAll,
    /// Update usage for a session
    Update { session_id: String, usage: ApiUsage },
}

impl Command for ApiUsageCommand {
    fn parse(input: &str) -> Result<Self, ParseError> {
        let parts: Vec<&str> = input.splitn(3, ' ').collect();

        match parts.as_slice() {
            ["API_USAGE", session_id] => {
                Ok(ApiUsageCommand::Query {
                    session_id: session_id.to_string()
                })
            }
            ["API_USAGE_ALL"] => {
                Ok(ApiUsageCommand::QueryAll)
            }
            ["SET_USAGE", session_id, json] => {
                let usage: ApiUsage = serde_json::from_str(json)
                    .map_err(|e| ParseError::InvalidJson(e.to_string()))?;
                Ok(ApiUsageCommand::Update {
                    session_id: session_id.to_string(),
                    usage,
                })
            }
            _ => Err(ParseError::UnknownCommand),
        }
    }
}
```

### Handler Implementation

```rust
impl ApiUsageCommand {
    pub fn execute(&self, store: &mut SessionStore) -> Response {
        match self {
            ApiUsageCommand::Query { session_id } => {
                match store.get_session(session_id) {
                    Some(session) => {
                        let usage = session.api_usage.clone()
                            .unwrap_or_default();
                        Response::Json(serde_json::to_string(&usage).unwrap())
                    }
                    None => Response::Error(format!(
                        "session not found: {}", session_id
                    )),
                }
            }
            ApiUsageCommand::QueryAll => {
                let usages: Vec<ApiUsage> = store.list_sessions()
                    .filter_map(|s| s.api_usage.clone())
                    .collect();
                let aggregate = ApiUsage::aggregate(&usages);

                // Include per-session summaries
                let response = AggregateUsageResponse {
                    session_count: usages.len(),
                    aggregate,
                    sessions: usages.iter()
                        .map(|u| SessionUsageSummary {
                            session_id: u.session_id.clone(),
                            total_tokens: u.total_tokens,
                        })
                        .collect(),
                };

                Response::Json(serde_json::to_string(&response).unwrap())
            }
            ApiUsageCommand::Update { session_id, usage } => {
                match store.update_usage(session_id, usage.clone()) {
                    Ok(()) => Response::Ok,
                    Err(e) => Response::Error(e.to_string()),
                }
            }
        }
    }
}
```

### Store Extension

```rust
impl SessionStore {
    /// Update API usage for a session
    pub fn update_usage(
        &mut self,
        session_id: &str,
        usage: ApiUsage
    ) -> Result<(), StoreError> {
        let session = self.active.get_mut(session_id)
            .ok_or(StoreError::SessionNotFound)?;

        // Merge with existing usage if present
        if let Some(existing) = &mut session.api_usage {
            existing.add_tokens(usage.input_tokens, usage.output_tokens);
            if usage.rate_limit_remaining.is_some() {
                existing.rate_limit_remaining = usage.rate_limit_remaining;
                existing.rate_limit_reset = usage.rate_limit_reset;
            }
        } else {
            session.api_usage = Some(usage);
        }

        Ok(())
    }

    /// Get aggregated usage across all sessions
    pub fn aggregate_usage(&self) -> ApiUsage {
        let usages: Vec<ApiUsage> = self.active.values()
            .filter_map(|s| s.api_usage.clone())
            .collect();
        ApiUsage::aggregate(&usages)
    }
}
```

### CLI Client Usage

```bash
# Query specific session usage
$ agent-console api-usage abc123
{
  "session_id": "abc123",
  "input_tokens": 1500,
  "output_tokens": 2300,
  ...
}

# Query all sessions
$ agent-console api-usage --all
{
  "session_count": 3,
  "total_tokens": 38000,
  ...
}
```

### Hook Integration

Hooks can call SET_USAGE to report usage:

```bash
#!/bin/bash
# Hook script that reports usage after each API call
SESSION_ID="$1"
USAGE_JSON="$2"

echo "SET_USAGE $SESSION_ID $USAGE_JSON" | nc -U /tmp/agent-console.sock
```

### Considerations

- **Idempotency**: SET_USAGE adds to existing totals rather than replacing
- **Partial updates**: SET_USAGE accepts partial usage data (only input_tokens,
  etc.)
- **Performance**: API_USAGE_ALL may be slow with many sessions; consider
  caching
- **Concurrency**: Use appropriate locking when updating usage data
