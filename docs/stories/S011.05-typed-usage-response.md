# Story: Typed Usage Response Structs

**Story ID:** S011.05 **Epic:**
[E011 - Claude Usage Crate](../epic/E011-claude-usage-crate.md) **Status:** Draft
**Priority:** P0 **Estimated Points:** 2

## Description

As a developer, I want the `claude-usage` crate to return typed, structured usage data, So that I can work with strongly-typed Rust structs instead of parsing JSON manually.

## Context

The Anthropic usage API returns a JSON response with utilization percentages and reset timestamps. This story defines Rust structs that map to this response and provides the main public API: `get_usage() -> Result<UsageData>`.

This is the final integration story that combines credential fetch (S011.02/03) and API client (S011.04) into a single, easy-to-use function.

## Implementation Details

### Technical Approach

1. Define structs matching API response shape using serde
2. Implement helper methods for common operations (time until reset, on-pace calculation)
3. Combine credential fetch + API call + parsing into single `get_usage()` function
4. Export types and main function as public API
5. Provide unified error type that wraps all sub-errors

### API Response Shape

```json
{
  "five_hour": { "utilization": 8.0, "resets_at": "2026-01-22T09:00:00Z" },
  "seven_day": { "utilization": 77.0, "resets_at": "2026-01-22T19:00:00Z" },
  "seven_day_sonnet": { "utilization": 0.0, "resets_at": "..." },
  "extra_usage": { "is_enabled": false, ... }
}
```

### Files to Create

- `crates/claude-usage/src/types.rs` - Type definitions and helper methods

### Files to Modify

- `crates/claude-usage/src/lib.rs` - Main `get_usage()` function and public exports
- `crates/claude-usage/Cargo.toml` - Add `serde`, `chrono` dependencies

### Dependencies

- S011.04: Usage API client must be implemented

## Acceptance Criteria

- [ ] Given valid API response, when parsed, then all fields are correctly populated
- [ ] Given missing optional fields (seven_day_sonnet, extra_usage), when parsed, then defaults are used
- [ ] Given `get_usage()` call succeeds, then `UsageData` is returned with all periods
- [ ] Given any error (credential, API, parse), when `get_usage()` fails, then unified `Error` type is returned
- [ ] Given `UsageData`, when helper methods called, then correct derived values computed

## Testing Requirements

- [ ] Unit test: Parse sample API response correctly
- [ ] Unit test: Handle missing optional fields gracefully
- [ ] Unit test: Helper methods compute correct values (time until reset, on-pace)
- [ ] Unit test: Serialization round-trip preserves data
- [ ] Integration test: Full `get_usage()` call with real credentials

## Out of Scope

- Caching of responses
- Historical data tracking
- Comparison between time periods

## Notes

### Type Definitions

```rust
// crates/claude-usage/src/types.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Main usage data returned by `get_usage()`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsageData {
    pub five_hour: UsagePeriod,
    pub seven_day: UsagePeriod,
    #[serde(default)]
    pub seven_day_sonnet: Option<UsagePeriod>,
    #[serde(default)]
    pub extra_usage: Option<ExtraUsage>,
}

/// Usage data for a specific time period
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsagePeriod {
    /// Percentage of quota used (0.0 - 100.0+)
    pub utilization: f64,
    /// When this period resets
    pub resets_at: DateTime<Utc>,
}

/// Extra usage billing information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtraUsage {
    pub is_enabled: bool,
    #[serde(default)]
    pub amount_used: Option<f64>,
    #[serde(default)]
    pub limit: Option<f64>,
}

impl UsagePeriod {
    /// Time remaining until reset
    pub fn time_until_reset(&self) -> chrono::Duration {
        self.resets_at - Utc::now()
    }

    /// Whether usage is on pace (utilization <= time elapsed %)
    pub fn is_on_pace(&self, period_hours: u32) -> bool {
        let total_seconds = period_hours as f64 * 3600.0;
        let remaining_seconds = self.time_until_reset().num_seconds() as f64;
        let elapsed_seconds = total_seconds - remaining_seconds;
        let elapsed_percent = (elapsed_seconds / total_seconds * 100.0).clamp(0.0, 100.0);

        self.utilization <= elapsed_percent
    }
}

impl UsageData {
    /// Whether 5-hour usage is on pace
    pub fn five_hour_on_pace(&self) -> bool {
        self.five_hour.is_on_pace(5)
    }

    /// Whether 7-day usage is on pace
    pub fn seven_day_on_pace(&self) -> bool {
        self.seven_day.is_on_pace(7 * 24)
    }
}
```

### Main Public API

```rust
// crates/claude-usage/src/lib.rs

pub mod types;
pub use types::{UsageData, UsagePeriod, ExtraUsage};

mod credentials;
mod client;
mod error;

pub use error::{Error, CredentialError, ApiError};

/// Fetch current Claude API usage data
///
/// This is the main entry point. It:
/// 1. Retrieves credentials from platform-specific storage
/// 2. Calls the Anthropic usage API
/// 3. Returns typed usage data
///
/// # Errors
///
/// Returns error if:
/// - Credentials not found or expired
/// - API call fails (network, auth, rate limit)
/// - Response parsing fails
///
/// # Example
///
/// ```no_run
/// use claude_usage::get_usage;
///
/// let usage = get_usage()?;
/// println!("5-hour utilization: {}%", usage.five_hour.utilization);
/// println!("7-day utilization: {}%", usage.seven_day.utilization);
/// ```
pub fn get_usage() -> Result<UsageData, Error> {
    let token = credentials::get_token()?;
    let response = client::fetch_usage_raw(&token)?;
    let usage: UsageData = serde_json::from_str(&response)
        .map_err(|e| Error::Parse(e.to_string()))?;
    Ok(usage)
}
```

### Unified Error Type

```rust
// crates/claude-usage/src/error.rs

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error(transparent)]
    Credential(#[from] CredentialError),

    #[error(transparent)]
    Api(#[from] ApiError),

    #[error("Failed to parse API response: {0}")]
    Parse(String),
}

// Re-export sub-errors for convenience
pub use crate::credentials::CredentialError;
pub use crate::client::ApiError;
```

### Dependencies

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
reqwest = { version = "0.11", features = ["blocking", "json"] }
thiserror = "1.0"

[target.'cfg(target_os = "macos")'.dependencies]
security-framework = "2.9"
```
