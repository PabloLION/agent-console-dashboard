# Story: Public API Implementation

**Story ID:** S014.05 **Epic:** [E014 - Claude Hooks Library](../epic/E014-claude-hooks-library.md) **Status:** Draft **Priority:** P0 **Estimated Points:** 3

## Description

As a developer, I want to implement the public API functions (install, uninstall, list), So that ACD daemon can programmatically manage Claude Code hooks.

## Context

This story ties together all previous work (types, settings I/O, registry I/O) into three public functions. The API orchestrates the workflows defined in architecture.md: read registry → check existence → modify settings → update registry → write both files.

Design decisions implemented: D16 (registry ownership), D20 (track only ours), D21 (list shows all).

## Implementation Details

### Technical Approach

1. Implement `install(event, handler, installed_by) -> Result<()>` in `src/lib.rs`
2. Implement `uninstall(event, command) -> Result<()>` in `src/lib.rs`
3. Implement `list() -> Result<Vec<ListEntry>>` in `src/lib.rs`
4. Wire together settings and registry operations per data flow diagrams
5. Handle error cases (hook exists, not managed, write failures)
6. Add integration tests for full workflows

### Files to Modify

- `src/lib.rs` - Implement public API functions
- `Cargo.toml` - No new dependencies

### File List

- `crates/claude-hooks/src/lib.rs` - Added install(), uninstall(), list() + 11 integration tests

### Dependencies

- S014.02 (types and errors)
- S014.03 (settings reader/writer)
- S014.04 (registry reader/writer)

## Acceptance Criteria

- [x] Given valid hook, when install() runs, then hook is added to settings.json and registry
- [x] Given duplicate hook, when install() runs, then AlreadyExists error is returned
- [x] Given managed hook, when uninstall() runs, then hook is removed from settings.json and registry
- [x] Given unmanaged hook, when uninstall() runs, then NotManaged error is returned
- [x] Given hooks in settings, when list() runs, then all hooks are returned with managed flags
- [x] Given registry write fails after settings write, when install() runs, then warning is logged but operation succeeds
- [x] Given settings write fails, when install() runs, then registry is unchanged

## Testing Requirements

- [x] Integration test: Install hook → verify in settings.json and registry
- [x] Integration test: Install duplicate hook → expect AlreadyExists error
- [x] Integration test: Uninstall managed hook → verify removed from both files
- [x] Integration test: Uninstall unmanaged hook → expect NotManaged error
- [x] Integration test: List hooks → verify managed and unmanaged distinction
- [x] Integration test: Install → list → uninstall → list (full cycle)
- [x] Edge case: Registry write fails after settings write (mock failure)
- [x] Edge case: Hook in registry but not in settings (uninstall should clean registry)
- [x] Edge case: Hook in settings but not in registry (list shows as unmanaged)

## Out of Scope

- CLI binary (v0.2+)
- Multi-scope support (v0.2+)
- Export/import (v0.2+)

## Notes

### install() Implementation

```rust
/// Install a hook for the specified event.
///
/// # Arguments
/// * `event` - Hook event (Start, Stop, etc.)
/// * `handler` - Hook handler configuration (command, timeout, etc.)
/// * `installed_by` - Free-form string identifying installer (e.g., "acd")
///
/// # Errors
/// * `HookError::AlreadyExists` - Hook already exists (in registry or settings)
/// * `SettingsError` - Failed to read or write settings.json
/// * `RegistryError` - Failed to read registry (write failure is logged but not returned)
///
/// # Example
/// ```rust,ignore
/// use claude_hooks::{HookEvent, HookHandler, install};
///
/// let handler = HookHandler {
///     r#type: "command".to_string(),
///     command: "/path/to/stop.sh".to_string(),
///     matcher: String::new(),
///     timeout: Some(600),
///     r#async: None,
/// };
///
/// install(HookEvent::Stop, handler, "acd")?;
/// ```
pub fn install(
    event: HookEvent,
    handler: HookHandler,
    installed_by: &str,
) -> Result<()> {
    use crate::settings::{read_settings, write_settings_atomic, add_hook};
    use crate::registry::{read_registry, write_registry, add_entry};
    use chrono::Local;

    // 1. Read registry
    let registry_entries = registry::read_registry()?;

    // 2. Check if hook exists in registry
    if registry_entries.iter().any(|e| e.matches(event, &handler.command)) {
        return Err(HookError::AlreadyExists {
            event,
            command: handler.command.clone(),
        }.into());
    }

    // 3. Read settings
    let settings = settings::read_settings()?;

    // 4. Check if hook exists in settings.json
    let hooks_array = settings
        .get("hooks")
        .and_then(|h| h.as_array())
        .ok_or_else(|| SettingsError::Parse("Missing 'hooks' array".to_string()))?;

    for hook in hooks_array {
        let hook_event = hook.get("event").and_then(|e| serde_json::from_value(e.clone()).ok());
        let hook_command = hook.get("command").and_then(|c| c.as_str());

        if hook_event == Some(event) && hook_command == Some(&handler.command) {
            return Err(HookError::AlreadyExists {
                event,
                command: handler.command.clone(),
            }.into());
        }
    }

    // 5. Add hook to settings
    let updated_settings = settings::add_hook(settings, event, handler.clone());

    // 6. Write settings atomically
    settings::write_settings_atomic(updated_settings)?;

    // 7. Create registry entry
    let timestamp = Local::now().format("%Y%m%d-%H%M%S").to_string();
    let entry = RegistryEntry {
        event,
        matcher: handler.matcher.clone(),
        r#type: handler.r#type.clone(),
        command: handler.command.clone(),
        timeout: handler.timeout,
        r#async: handler.r#async,
        scope: "user".to_string(),
        enabled: true,
        added_at: timestamp,
        installed_by: installed_by.to_string(),
        description: None,
        reason: None,
        optional: None,
    };

    // 8. Add entry to registry
    let updated_registry = registry::add_entry(registry_entries, entry);

    // 9. Write registry (log warning on failure, don't fail operation)
    if let Err(e) = registry::write_registry(updated_registry) {
        log::warn!("Failed to write registry after successful settings write: {}", e);
        log::warn!("Hook installed but not tracked. Remove manually from settings.json if needed.");
    }

    Ok(())
}
```

### uninstall() Implementation

```rust
/// Uninstall a hook for the specified event and command.
///
/// Only removes hooks installed via this crate (matched via registry).
///
/// # Arguments
/// * `event` - Hook event
/// * `command` - Exact command string
///
/// # Errors
/// * `HookError::NotManaged` - Hook not found in registry (not managed by us)
/// * `SettingsError` - Failed to read or write settings.json
/// * `RegistryError` - Failed to read registry (write failure is logged but not returned)
///
/// # Example
/// ```rust,ignore
/// use claude_hooks::{HookEvent, uninstall};
///
/// uninstall(HookEvent::Stop, "/path/to/stop.sh")?;
/// ```
pub fn uninstall(event: HookEvent, command: &str) -> Result<()> {
    use crate::settings::{read_settings, write_settings_atomic, remove_hook};
    use crate::registry::{read_registry, write_registry, remove_entry};

    // 1. Read registry
    let registry_entries = registry::read_registry()?;

    // 2. Check if hook exists in registry
    if !registry_entries.iter().any(|e| e.matches(event, command)) {
        return Err(HookError::NotManaged {
            event,
            command: command.to_string(),
        }.into());
    }

    // 3. Read settings
    let settings = settings::read_settings()?;

    // 4. Check if hook exists in settings.json
    let hooks_array = settings
        .get("hooks")
        .and_then(|h| h.as_array())
        .ok_or_else(|| SettingsError::Parse("Missing 'hooks' array".to_string()))?;

    let hook_in_settings = hooks_array.iter().any(|hook| {
        let hook_event = hook.get("event").and_then(|e| serde_json::from_value(e.clone()).ok());
        let hook_command = hook.get("command").and_then(|c| c.as_str());
        hook_event == Some(event) && hook_command == Some(command)
    });

    if !hook_in_settings {
        log::warn!("Hook in registry but not in settings.json: {:?} - {}", event, command);
        log::warn!("Removing from registry anyway (user may have manually deleted)");
    }

    // 5. Remove hook from settings (if exists)
    let updated_settings = settings::remove_hook(settings, event, command);

    // 6. Write settings atomically
    settings::write_settings_atomic(updated_settings)?;

    // 7. Remove entry from registry
    let updated_registry = registry::remove_entry(registry_entries, event, command);

    // 8. Write registry (log warning on failure, don't fail operation)
    if let Err(e) = registry::write_registry(updated_registry) {
        log::warn!("Failed to write registry after successful settings write: {}", e);
        log::warn!("Hook removed but registry dirty. May show as managed until registry fixed.");
    }

    Ok(())
}
```

### list() Implementation

```rust
/// List all hooks from settings.json with management status.
///
/// Returns all hooks (managed and unmanaged). Managed hooks include metadata.
///
/// # Errors
/// * `SettingsError` - Failed to read or parse settings.json
/// * `RegistryError` - Failed to read or parse registry
///
/// # Example
/// ```rust,ignore
/// use claude_hooks::list;
///
/// for entry in list()? {
///     if entry.managed {
///         println!("Managed: {:?} - {}", entry.event, entry.handler.command);
///     } else {
///         println!("Unmanaged: {:?} - {}", entry.event, entry.handler.command);
///     }
/// }
/// ```
pub fn list() -> Result<Vec<ListEntry>> {
    use crate::settings::read_settings;
    use crate::registry::read_registry;

    // 1. Read registry
    let registry_entries = registry::read_registry()?;

    // 2. Read settings
    let settings = settings::read_settings()?;

    // 3. Parse hooks from settings.json
    let hooks_array = settings
        .get("hooks")
        .and_then(|h| h.as_array())
        .ok_or_else(|| SettingsError::Parse("Missing 'hooks' array".to_string()))?;

    let mut results = Vec::new();

    for hook in hooks_array {
        let event: HookEvent = hook.get("event")
            .and_then(|e| serde_json::from_value(e.clone()).ok())
            .ok_or_else(|| SettingsError::Parse("Invalid event in hook".to_string()))?;

        let handler: HookHandler = serde_json::from_value(hook.clone())
            .map_err(|e| SettingsError::Parse(format!("Invalid hook handler: {}", e)))?;

        // Check if hook exists in registry
        let registry_entry = registry_entries.iter()
            .find(|e| e.matches(event, &handler.command));

        let (managed, metadata) = if let Some(entry) = registry_entry {
            let metadata = RegistryMetadata {
                added_at: entry.added_at.clone(),
                installed_by: entry.installed_by.clone(),
                description: entry.description.clone(),
                reason: entry.reason.clone(),
                optional: entry.optional,
            };
            (true, Some(metadata))
        } else {
            (false, None)
        };

        results.push(ListEntry {
            event,
            handler,
            managed,
            metadata,
        });
    }

    Ok(results)
}
```

### Integration Test Example

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_install_list_uninstall_workflow() {
        // Use temp directory for test files
        let dir = tempdir().unwrap();
        // Setup test environment with temp settings.json and registry

        // Install hook
        let handler = HookHandler {
            r#type: "command".to_string(),
            command: "/path/to/stop.sh".to_string(),
            matcher: String::new(),
            timeout: Some(600),
            r#async: None,
        };

        install(HookEvent::Stop, handler.clone(), "test").unwrap();

        // List hooks - should show as managed
        let entries = list().unwrap();
        assert_eq!(entries.len(), 1);
        assert!(entries[0].managed);
        assert_eq!(entries[0].event, HookEvent::Stop);

        // Uninstall hook
        uninstall(HookEvent::Stop, "/path/to/stop.sh").unwrap();

        // List hooks - should be empty
        let entries = list().unwrap();
        assert_eq!(entries.len(), 0);
    }

    #[test]
    fn test_install_duplicate_fails() {
        let handler = HookHandler {
            r#type: "command".to_string(),
            command: "/path/to/stop.sh".to_string(),
            matcher: String::new(),
            timeout: Some(600),
            r#async: None,
        };

        install(HookEvent::Stop, handler.clone(), "test").unwrap();

        let result = install(HookEvent::Stop, handler, "test");
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), Error::Hook(HookError::AlreadyExists { .. })));
    }

    #[test]
    fn test_uninstall_unmanaged_fails() {
        // Manually add hook to settings.json (not via install)
        // Then try to uninstall

        let result = uninstall(HookEvent::Stop, "/unmanaged/hook.sh");
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), Error::Hook(HookError::NotManaged { .. })));
    }
}
```

### Error Handling Strategy

Per architecture.md data flow diagrams:

**Install:**
- If settings write fails → registry unchanged, return error
- If registry write fails after settings write → log warning, return Ok (hook installed but untracked)

**Uninstall:**
- If hook not in registry → return NotManaged error immediately
- If hook in registry but not in settings → log warning, remove from registry anyway
- If registry write fails after settings write → log warning, return Ok (hook removed but registry dirty)

**List:**
- If settings read fails → return error
- If registry read fails → return error (cannot determine managed status)

## Commit Checkpoint

This story marks a commit checkpoint per implementation plan Phase 5. Commit message:

```text
feat: implement install, uninstall, and list public API

- Wire together settings and registry operations
- Implement error handling per data flow diagrams
- Add integration tests for full workflows
- Handle edge cases (registry write failures, out-of-sync state)
```

## Dev Agent Record

### Implementation Summary

Implemented three public API functions in `src/lib.rs`:

1. **`install(event, handler, installed_by)`** - Installs a hook with atomic safety
   - Checks registry and settings for duplicates (AlreadyExists error if found)
   - Writes to settings.json atomically
   - Writes to registry (logs warning on failure, doesn't fail operation)
   - Creates registry entry with timestamp and installer metadata

2. **`uninstall(event, command)`** - Removes a managed hook
   - Checks registry for management status (NotManaged error if not found)
   - Removes from settings.json atomically
   - Removes from registry (logs warning on failure)
   - Handles edge case where hook is in registry but not settings (warns, cleans up)

3. **`list()`** - Lists all hooks with management status
   - Reads registry and settings.json
   - Matches hooks against registry to determine managed status
   - Returns managed and unmanaged hooks with appropriate metadata

### Integration Tests

Added 11 integration tests covering:
- Full workflow (install → list → uninstall → list)
- Duplicate detection (install twice)
- Unmanaged hook rejection (uninstall non-existent)
- Mixed managed/unmanaged hooks (list shows distinction)
- Multiple hooks (same event different commands, different events)
- Edge cases (hook in registry but not settings, optional fields)
- Metadata preservation

All tests use `#[serial(integration)]` to avoid race conditions with HOME environment variable.

### Test Execution

Tests pass reliably with `--test-threads=1` due to global HOME modification:
```bash
cargo test -p claude-hooks --lib -- --test-threads=1
```

39 tests pass (2 ignored filesystem tests require `--ignored` flag).

### Design Decisions

- **Error handling**: Registry write failures after settings write are logged but don't fail the operation (per D16)
- **Composite key**: Used `RegistryEntry::matches(event, command)` for hook identity (per D22)
- **Logging**: Used `log::warn!()` for non-fatal errors (registry write failures, out-of-sync state)
- **Atomicity**: Settings writes use atomic temp-file-then-rename pattern from settings module
