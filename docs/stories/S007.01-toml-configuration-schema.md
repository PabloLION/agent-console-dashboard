# Story: Define TOML Configuration Schema

**Story ID:** S007.01 **Epic:**
[E007 - Configuration System](../epic/E007-configuration-system.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 3

## Description

As a developer, I want a well-defined TOML configuration schema with Rust types,
So that configuration can be parsed, validated, and used throughout the
application.

## Context

The Agent Console Dashboard needs a centralized configuration system to manage
UI preferences, agent integrations, and daemon settings. TOML is chosen for its
readability and strong Rust ecosystem support (via `toml` and `serde` crates).
This story defines the schema structure and corresponding Rust types that will
be used by all other configuration-related functionality.

The schema must balance flexibility (supporting future extensions) with
simplicity (users shouldn't need to configure everything). All fields should
have sensible defaults, making configuration optional for most users.

## Implementation Details

### Technical Approach

1. Define Rust structs with `serde::Deserialize` for each configuration section
2. Use `#[serde(default)]` for optional fields with sensible defaults
3. Implement `Default` trait for all config structs
4. Add validation logic for enum fields (layout types, widget names)
5. Create comprehensive doc comments explaining each field

### Files to Modify

- `crates/agent-console-dashboard/src/config/mod.rs` - Create config module with
  schema types
- `crates/agent-console-dashboard/src/config/schema.rs` - Define configuration
  structs
- `crates/agent-console-dashboard/src/lib.rs` - Export config module
- `Cargo.toml` - Add `toml` and `serde` dependencies

### Dependencies

- None (this is foundational for E007)

## Acceptance Criteria

- [ ] Given a valid TOML configuration string, when parsed, then it deserializes
      into Config struct without errors
- [ ] Given a configuration with missing optional fields, when parsed, then
      default values are used
- [ ] Given a configuration with invalid enum values, when parsed, then a
      descriptive error is returned
- [ ] Given the schema types, when examined, then all fields have doc comments
      explaining their purpose
- [ ] Given a Config struct, when serialized, then it produces valid TOML
      matching the schema
- [ ] Given the schema, when reviewed, then it supports all sections: `[ui]`,
      `[agents.*]`, `[integrations.*]`, `[daemon]`

## Testing Requirements

- [ ] Unit test: Parse valid configuration with all fields specified
- [ ] Unit test: Parse configuration with only required fields (defaults for
      rest)
- [ ] Unit test: Parse configuration with unknown fields (should be ignored or
      error based on design)
- [ ] Unit test: Validation rejects invalid layout values
- [ ] Unit test: Validation rejects invalid widget names
- [ ] Unit test: Default configuration values are sensible

## Out of Scope

- Loading configuration from file system (S007.02)
- XDG path resolution (S007.03)
- Creating default configuration file on disk (S007.04)
- Runtime configuration reloading
- Configuration file watching

## Notes

### Configuration Schema

```toml
# Agent Console Dashboard Configuration

[ui]
# Layout preset: "one-line", "two-line", "detailed", "history"
layout = "two-line"

# Widgets to display in the dashboard
widgets = ["session-status", "working-dir", "api-usage"]

# Color scheme: "dark", "light", "auto"
color_scheme = "dark"

[agents.claude-code]
# Enable Claude Code integration
enabled = true

# Path to Claude Code hooks directory
hooks_path = "~/.claude/hooks"

[integrations.zellij]
# Enable Zellij integration for session resurrection
enabled = true

[daemon]
# Unix socket path (relative to XDG_RUNTIME_DIR or /tmp)
socket_path = "agent-console.sock"

# Log level: "error", "warn", "info", "debug", "trace"
log_level = "info"
```

### Rust Schema Types

```rust
use serde::Deserialize;

#[derive(Debug, Clone, Deserialize, Default)]
pub struct Config {
    #[serde(default)]
    pub ui: UiConfig,
    #[serde(default)]
    pub agents: AgentsConfig,
    #[serde(default)]
    pub integrations: IntegrationsConfig,
    #[serde(default)]
    pub daemon: DaemonConfig,
}

#[derive(Debug, Clone, Deserialize)]
pub struct UiConfig {
    #[serde(default = "default_layout")]
    pub layout: Layout,
    #[serde(default = "default_widgets")]
    pub widgets: Vec<String>,
    #[serde(default = "default_color_scheme")]
    pub color_scheme: ColorScheme,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum Layout {
    OneLine,
    TwoLine,
    Detailed,
    History,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum ColorScheme {
    Dark,
    Light,
    Auto,
}

#[derive(Debug, Clone, Deserialize, Default)]
pub struct AgentsConfig {
    #[serde(default)]
    pub claude_code: ClaudeCodeConfig,
}

#[derive(Debug, Clone, Deserialize)]
pub struct ClaudeCodeConfig {
    #[serde(default = "default_true")]
    pub enabled: bool,
    #[serde(default = "default_hooks_path")]
    pub hooks_path: String,
}

#[derive(Debug, Clone, Deserialize, Default)]
pub struct IntegrationsConfig {
    #[serde(default)]
    pub zellij: ZellijConfig,
}

#[derive(Debug, Clone, Deserialize)]
pub struct ZellijConfig {
    #[serde(default = "default_true")]
    pub enabled: bool,
}

#[derive(Debug, Clone, Deserialize)]
pub struct DaemonConfig {
    #[serde(default = "default_socket_path")]
    pub socket_path: String,
    #[serde(default = "default_log_level")]
    pub log_level: LogLevel,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum LogLevel {
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}
```

### Design Decisions

1. **Flat agent/integration structure**: Using `[agents.claude-code]` instead of
   arrays allows easy access and clear identification
2. **String widget list**: Widgets are specified by name (string) rather than
   complex structures for simplicity
3. **All fields optional**: Users can start with an empty config file and get
   sensible defaults
4. **Kebab-case enums**: More readable in TOML (`"two-line"` vs `"TwoLine"`)

### Future Extensions

The schema should be designed to accommodate:

- Additional agents beyond Claude Code
- Custom widget configurations
- Theme customization beyond color scheme
- Notification settings
