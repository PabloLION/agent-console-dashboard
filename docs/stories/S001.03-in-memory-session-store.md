# Story: Implement In-Memory Session Store

**Story ID:** S001.03 **Epic:**
[E001 - Daemon Core Infrastructure](../epic/E001-daemon-core-infrastructure.md)
**Status:** Draft **Priority:** P1 **Estimated Points:** 5

## Description

As a daemon, I want to store session state in memory using a HashMap, So that I
can track all active agent sessions efficiently.

## Context

The session store is the in-memory data structure that holds all session state.
It uses a HashMap for O(1) lookups by session ID. With the **single-threaded
actor model**, the store is a plain `HashMap<String, Session>` with no locks
needed. See [concurrency model](../architecture/concurrency.md) and
[D1](../architecture/2026-01-31-discussion-decisions.md).

Key design decisions:

- In-memory only (no persistence) - sessions are volatile/transient
- `HashMap<String, Session>` for simple key-value access
- **No `Arc<RwLock>` needed** - single event loop owns the HashMap
- State lost on daemon restart is acceptable (sessions refresh quickly through
  hooks)
- The HashMap is mutated sequentially by the single event loop processing mpsc
  messages

## Implementation Details

### Technical Approach

1. Create `daemon/store.rs` for the session store implementation
2. Define core data structures (Session, Status, StateTransition) - see S002.01
   for full data model
3. Implement Store struct wrapping plain HashMap (no locks)
4. Add methods: get, set, remove, list_all
5. Store is owned by the event loop, mutated via message handlers
6. Implement Clone/Debug for debugging support

### Concurrency Pattern

```rust
// No Arc, no RwLock â€” just a plain HashMap
struct DaemonState {
    sessions: HashMap<SessionId, Session>,
    usage: Option<UsageData>,
    subscribers: Vec<ClientConnection>,
}

fn update_session(state: &mut DaemonState, id: SessionId, status: Status) {
    if let Some(session) = state.sessions.get_mut(&id) {
        session.status = status;
        broadcast_update(state, id);
    }
}
```

The event loop owns `DaemonState` and processes messages sequentially:

```rust
let mut state = DaemonState::new();

loop {
    tokio::select! {
        Some(msg) = rx.recv() => {
            // Process message, mutate state directly
            match msg {
                Message::Set { id, status } => update_session(&mut state, id, status),
                Message::Get { id, tx } => tx.send(state.sessions.get(&id)),
                // ...
            }
        }
        // ... other event handlers
    }
}
```

### Files to Create/Modify

- `crates/agent-console-dashboard/src/daemon/mod.rs` - Export store module
- `crates/agent-console-dashboard/src/daemon/store.rs` - Session store
  implementation
- `crates/agent-console-dashboard/src/lib.rs` - Shared types (Session, Status,
  etc.) if needed

### Dependencies

- S001.01: Daemon process provides the runtime context

## Acceptance Criteria

- [ ] Given a new session ID, when `set` is called, then a new session is
      created in the store
- [ ] Given an existing session, when `get` is called with its ID, then the
      session data is returned
- [ ] Given an existing session, when `set` is called with updated status, then
      the session is updated
- [ ] Given an existing session, when `remove` is called, then the session is
      removed from the store
- [ ] Given multiple sessions, when `list_all` is called, then all sessions are
      returned
- [ ] Given the store implementation, then it uses a plain HashMap with no locks
      (no `Arc<RwLock>`)
- [ ] Given daemon running with sessions, when memory is measured, then RAM
      usage is under 5MB target

## Testing Requirements

- [ ] Unit test: Create, read, update, delete session operations
- [ ] Unit test: list_all returns all sessions
- [ ] Unit test: get returns None for non-existent session
- [ ] Unit test: Store uses plain HashMap (verify via type signature)
- [ ] Benchmark: Memory usage with 100 sessions under 1MB

## Out of Scope

- State history tracking (S002.03 - Session State History)
- Session lifecycle event handling (S002.04)
- API usage tracking (E011 - claude-usage integration)
- Session resurrection metadata (E008 - Session Resurrection)
- IPC commands for manipulating store (E003 - IPC Protocol)
- Thread-safety concerns (not needed with single-threaded actor model)

## Notes

### Data Model (Basic)

Full data model defined in S002.01. Basic structure:

```rust
/// Session state with history
struct Session {
    id: String,
    agent_type: AgentType,       // ClaudeCode, Future agents
    status: Status,
    working_dir: PathBuf,        // From cwd in JSON stdin
    display_name: String,        // Derived from basename of cwd
    since: Instant,              // When status last changed
    history: Vec<StateTransition>,
    closed: bool,                // For resurrection feature
}

enum Status {
    Working,
    Attention,
    Question,
    Closed,
}

enum AgentType {
    ClaudeCode,
    // Future: Other agents
}

struct StateTransition {
    timestamp: Instant,
    from: Status,
    to: Status,
    duration: Duration,
}

// Note: Per-session API usage is NOT stored in Session.
// Account-level quota is fetched by daemon via claude_usage::get_usage() (E011)
// and broadcast to all TUIs. See D3 (Widget Data Flow).
```

### Store Pattern - No Locks

```rust
// Plain HashMap owned by event loop
struct DaemonState {
    sessions: HashMap<String, Session>,
}

impl DaemonState {
    fn get(&self, id: &str) -> Option<&Session> {
        self.sessions.get(id)
    }

    fn set(&mut self, id: String, session: Session) {
        self.sessions.insert(id, session);
    }

    fn remove(&mut self, id: &str) -> Option<Session> {
        self.sessions.remove(id)
    }

    fn list_all(&self) -> Vec<&Session> {
        self.sessions.values().collect()
    }
}
```

### Memory Estimation

| Component            | Size per Session |
| -------------------- | ---------------- |
| Session struct       | ~200 bytes       |
| ID string            | ~50 bytes        |
| History (10 entries) | ~400 bytes       |
| Total per session    | ~650 bytes       |
| 100 sessions         | ~65KB            |

### Session Identification

Sessions are identified by `session_id` from Claude Code's JSON stdin, available
in ALL hook types (Stop, UserPromptSubmit, Notification, PreToolUse,
SessionStart, SessionEnd). See
[D8](../architecture/2026-01-31-discussion-decisions.md).

Hook scripts extract session_id from stdin:

```bash
INPUT=$(cat)
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id')
agent-console set "$SESSION_ID" working
```

**Session auto-creation:** First SET for an unknown session_id creates the
session automatically. No explicit registration step needed.
