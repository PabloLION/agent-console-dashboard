# Story: macOS Keychain Credential Fetch

**Story ID:** S011.02 **Epic:**
[E011 - Claude Usage Crate](../epic/E011-claude-usage-crate.md) **Status:** Done
**Priority:** P0 **Estimated Points:** 3

## Description

As a macOS user, I want the `claude-usage` crate to fetch OAuth credentials from the macOS Keychain, So that I can retrieve my API usage without manually providing credentials.

## Context

Claude Code stores OAuth credentials in the macOS Keychain under service name `"Claude Code-credentials"`. The credential is a JSON object containing the access token needed for API calls. This story implements secure retrieval of these credentials on macOS using the `security-framework` crate.

Critical security requirement: credentials must be read, used immediately, and discarded. No storing tokens in memory beyond the immediate API call.

## Implementation Details

### Technical Approach

1. Use `security-framework` crate for Keychain access
2. Query for generic password with service `"Claude Code-credentials"` and account `""`
3. Parse JSON to extract `claudeAiOauth.accessToken`
4. Check `expiresAt` timestamp to detect expired tokens
5. Return token or appropriate error
6. Ensure token is never logged or retained beyond function scope

### Credential Format

```json
{
  "claudeAiOauth": {
    "accessToken": "sk-ant-oat01-...",
    "refreshToken": "sk-ant-ort01-...",
    "expiresAt": 1748658860401,
    "scopes": ["user:inference", "user:profile"]
  }
}
```

### Files to Create

- `crates/claude-usage/src/credentials/mod.rs` - Credentials module
- `crates/claude-usage/src/credentials/macos.rs` - macOS Keychain implementation
- `crates/claude-usage/src/error.rs` - Error types

### Files to Modify

- `crates/claude-usage/src/lib.rs` - Export credentials module
- `crates/claude-usage/Cargo.toml` - Add `security-framework` dependency

### Dependencies

- S011.01: Workspace restructure must be complete

## Acceptance Criteria

- [ ] Given valid credentials in Keychain, when `get_token()` is called, then access token is returned
- [ ] Given no credentials in Keychain, when `get_token()` is called, then `CredentialNotFound` error is returned
- [ ] Given expired credentials (current time > expiresAt), when `get_token()` is called, then `TokenExpired` error is returned
- [ ] Given malformed credential JSON, when `get_token()` is called, then `ParseError` is returned
- [ ] Given successful retrieval, when function returns, then token is not retained in memory
- [ ] Given multiple calls, when executed, then Keychain is queried each time (no caching)

## Testing Requirements

- [ ] Unit test: Parse valid credential JSON correctly
- [ ] Unit test: Detect expired token based on `expiresAt` field
- [ ] Unit test: Handle missing `accessToken` field
- [ ] Unit test: Handle missing `claudeAiOauth` field
- [ ] Manual test: Retrieve real credential from Keychain (requires Claude Code installed)

## Out of Scope

- Token refresh (Claude Code CLI handles this)
- Credential caching (every call queries Keychain fresh)
- Writing credentials to Keychain
- Keychain ACL modification

## Notes

### Implementation

```rust
// crates/claude-usage/src/credentials/macos.rs

use security_framework::passwords::get_generic_password;
use serde_json::Value;

pub fn get_token_macos() -> Result<String, CredentialError> {
    // Read from Keychain
    let password_bytes = get_generic_password("Claude Code-credentials", "")
        .map_err(|_| CredentialError::NotFound)?;

    // Parse JSON
    let json: Value = serde_json::from_slice(&password_bytes)
        .map_err(|e| CredentialError::Parse(e.to_string()))?;

    // Extract OAuth object
    let oauth = json.get("claudeAiOauth")
        .ok_or(CredentialError::MissingField("claudeAiOauth"))?;

    // Check expiration
    if let Some(expires_at) = oauth.get("expiresAt").and_then(|v| v.as_i64()) {
        let now_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as i64;

        if now_ms > expires_at {
            return Err(CredentialError::Expired);
        }
    }

    // Extract access token
    let token = oauth.get("accessToken")
        .and_then(|v| v.as_str())
        .ok_or(CredentialError::MissingField("accessToken"))?;

    Ok(token.to_string())
}
```

### Error Types

```rust
// crates/claude-usage/src/error.rs

#[derive(Debug, thiserror::Error)]
pub enum CredentialError {
    #[error("Claude Code credentials not found in Keychain. Run `claude` to login.")]
    NotFound,

    #[error("Credentials expired. Run `claude` to re-login.")]
    Expired,

    #[error("Failed to parse credentials: {0}")]
    Parse(String),

    #[error("Missing field in credentials: {0}")]
    MissingField(&'static str),
}
```

### Keychain ACL Considerations

macOS Keychain may prompt for access approval depending on ACL settings. See [macOS Keychain ACL documentation](../macos-keychain-acl.md) for details on how access control lists affect credential retrieval.

If Keychain prompts appear frequently, users can grant permanent access via Keychain Access.app.

### Security Practices

- Token retrieved → used immediately in API call → dropped
- No logging of token value (not even redacted)
- No storage in struct fields beyond function scope
- No passing token between modules (use callback pattern if needed)
- Consider `secrecy` crate for additional protection if needed in future

### Platform Detection

```rust
// crates/claude-usage/src/credentials/mod.rs

#[cfg(target_os = "macos")]
mod macos;

#[cfg(target_os = "macos")]
pub use macos::get_token_macos as get_token;

#[cfg(target_os = "linux")]
pub use linux::get_token_linux as get_token;
```

### Dependencies

```toml
[target.'cfg(target_os = "macos")'.dependencies]
security-framework = "2.9"
```
