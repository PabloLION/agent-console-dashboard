# Story: Implement In-Memory Session Store

**Story ID:** S1.3 **Epic:**
[E001 - Daemon Core Infrastructure](../epic/E001-daemon-core-infrastructure.md)
**Status:** Draft **Priority:** P1 **Estimated Points:** 5

## Description

As a daemon, I want to store session state in memory using a HashMap, So that I
can track all active agent sessions efficiently.

## Context

The session store is the in-memory data structure that holds all session state.
It uses a HashMap for O(1) lookups by session ID. The store must be thread-safe
since multiple async tasks may access it concurrently (socket handlers updating
state, subscribers reading state).

Key design decisions:

- In-memory only (no persistence) - sessions are volatile/transient
- `HashMap<String, Session>` for simple key-value access
- Thread-safe access via `Arc<RwLock<Store>>`
- State lost on crash is acceptable (sessions refresh quickly through normal
  use)

## Implementation Details

### Technical Approach

1. Create `daemon/store.rs` for the session store implementation
2. Define core data structures (Session, Status, StateTransition)
3. Implement Store struct wrapping HashMap with RwLock
4. Add methods: get, set, remove, list_all
5. Ensure thread-safe access for concurrent operations
6. Implement Clone/Debug for debugging support

### Files to Modify

- `src/daemon/mod.rs` - Export store module
- `src/daemon/store.rs` - Session store implementation
- `src/lib.rs` - Shared types (Session, Status, etc.)

### Dependencies

- S1.1: Daemon process provides the runtime context

## Acceptance Criteria

- [ ] Given a new session ID, when `set` is called, then a new session is
      created in the store
- [ ] Given an existing session, when `get` is called with its ID, then the
      session data is returned
- [ ] Given an existing session, when `set` is called with updated status, then
      the session is updated
- [ ] Given an existing session, when `remove` is called, then the session is
      removed from the store
- [ ] Given multiple sessions, when `list_all` is called, then all sessions are
      returned
- [ ] Given concurrent access from multiple tasks, when operations occur
      simultaneously, then no data corruption occurs
- [ ] Given daemon running with sessions, when memory is measured, then RAM
      usage is under 5MB

## Testing Requirements

- [ ] Unit test: Create, read, update, delete session operations
- [ ] Unit test: list_all returns all sessions
- [ ] Unit test: get returns None for non-existent session
- [ ] Integration test: Concurrent access from multiple tasks is safe
- [ ] Benchmark: Memory usage with 100 sessions under 1MB

## Out of Scope

- State history tracking (S2.3 - Session State History)
- API usage tracking (E009 - API Usage Tracking)
- Session resurrection metadata (E008 - Session Resurrection)
- IPC commands for manipulating store (E003 - IPC Protocol)

## Notes

### Data Model

```rust
/// Session state with history
struct Session {
    id: String,
    agent_type: AgentType,       // ClaudeCode, Future agents
    status: Status,
    working_dir: PathBuf,
    since: Instant,              // When status last changed
    history: Vec<StateTransition>,
    api_usage: Option<ApiUsage>,
    closed: bool,                // For resurrection feature
    session_id: Option<String>,  // Claude Code session ID for resume
}

enum Status {
    Working,
    Attention,
    Question,
    Closed,
}

enum AgentType {
    ClaudeCode,
    // Future: Other agents
}

struct StateTransition {
    timestamp: Instant,
    from: Status,
    to: Status,
    duration: Duration,
}

struct ApiUsage {
    input_tokens: u64,
    output_tokens: u64,
}

// Thread-safe store
type Store = Arc<RwLock<HashMap<String, Session>>>;
```

### Thread Safety Pattern

```rust
// Shared store passed to handlers
let store = Arc::new(RwLock::new(HashMap::new()));

// Read access (multiple readers allowed)
let sessions = store.read().await;
let session = sessions.get(&id);

// Write access (exclusive)
let mut sessions = store.write().await;
sessions.insert(id, session);
```

### Memory Estimation

| Component            | Size per Session |
| -------------------- | ---------------- |
| Session struct       | ~200 bytes       |
| ID string            | ~50 bytes        |
| History (10 entries) | ~400 bytes       |
| Total per session    | ~650 bytes       |
| 100 sessions         | ~65KB            |
