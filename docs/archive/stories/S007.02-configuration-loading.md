# Story: Implement Configuration Loading

**Story ID:** S007.02 **Epic:**
[E007 - Configuration System](../epic/E007-configuration-system.md) **Status:**
Draft **Priority:** P1 **Estimated Points:** 3

## Description

As a developer, I want configuration to be loaded from the TOML file at startup,
So that user preferences are applied when the daemon or dashboard starts.

## Context

With the configuration schema defined (S007.01), this story implements the
actual loading mechanism. The configuration loader must handle various
scenarios: file exists with valid config, file exists with invalid config, file
doesn't exist (use defaults), and permission errors. Error messages must be
user-friendly, pointing to the exact line and column of any parsing errors.

The loader integrates with the XDG path resolution (S007.03) to find the
configuration file, but this story focuses on the loading and parsing logic
itself, with path resolution abstracted through a trait or function parameter.

Per [E007 epic](../epic/E007-configuration-system.md#hot-reload-scope), the
daemon supports hot-reload via `kill -HUP <pid>` or `acd reload`. Invalid config
on reload keeps the previous config and logs the error.

## Implementation Details

### Technical Approach

1. Create `ConfigLoader` struct with methods for loading configuration
2. Implement file reading with proper error handling
3. Use `toml::from_str()` for parsing with position-aware error reporting
4. Provide `load_from_path()` for explicit path and `load_default()` for
   standard location
5. Return `Result<Config, ConfigError>` with descriptive error types
6. Add hot-reload handler for SIGHUP that reloads config and updates reloadable
   settings

### Files to Modify

- `crates/agent-console-dashboard/src/config/loader.rs` - Create configuration
  loader implementation
- `crates/agent-console-dashboard/src/config/error.rs` - Define configuration
  error types
- `crates/agent-console-dashboard/src/config/mod.rs` - Export loader module
- `crates/agent-console-dashboard/src/daemon/main.rs` - Integrate config loading
  at daemon startup
- `crates/agent-console-dashboard/src/tui/main.rs` - Integrate config loading at
  TUI startup
- `crates/agent-console-dashboard/src/daemon/reload.rs` - Add SIGHUP handler for
  hot-reload

### Dependencies

- [S007.01 - TOML Configuration Schema](./S007.01-toml-configuration-schema.md) -
  Schema types must be defined first
- [S007.03 - XDG Path Support](./S007.03-xdg-path-support.md) - For default path
  resolution (can develop in parallel with path as parameter)

## Acceptance Criteria

- [ ] Given a valid config file at the specified path, when `load_from_path()`
      is called, then Config is returned
- [ ] Given an invalid TOML file, when loading, then error includes file path,
      line number, and column (e.g.,
      `Invalid configuration at config.toml:12:5: invalid value`)
- [ ] Given a non-existent config file, when `load_default()` is called, then
      default Config is returned
- [ ] Given a file with permission errors, when loading, then a descriptive
      error is returned
- [ ] Given daemon startup, when config loading fails with invalid TOML, then
      daemon exits with helpful error message
- [ ] Given TUI startup, when config loading fails, then error is displayed
      before exit
- [ ] Given partial configuration, when loading, then missing fields use schema
      defaults
- [ ] Given daemon receives SIGHUP, when config is reloaded, then hot-reloadable
      settings are updated
- [ ] Given invalid config on reload, when SIGHUP is received, then daemon keeps
      old config and logs error

## Testing Requirements

- [ ] Unit test: Load valid configuration from string
- [ ] Unit test: Load valid configuration from file
- [ ] Unit test: Handle missing file gracefully with defaults
- [ ] Unit test: Parse error includes line and column information
- [ ] Unit test: IO error includes file path
- [ ] Integration test: Daemon starts with valid config file
- [ ] Integration test: Daemon exits gracefully with invalid config file
- [ ] Integration test: SIGHUP reloads config successfully
- [ ] Integration test: Invalid config on reload keeps old config

## Out of Scope

- XDG path resolution implementation (S007.03)
- Creating default configuration file (S007.04)
- Configuration validation beyond TOML parsing
- Environment variable overrides

## Notes

### Error Types

```rust
use std::path::PathBuf;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("Failed to read configuration file: {path}")]
    ReadError {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("Invalid configuration at {path}:{line}:{column}: {message}")]
    ParseError {
        path: PathBuf,
        line: usize,
        column: usize,
        message: String,
    },

    #[error("Configuration file not found: {path}")]
    NotFound { path: PathBuf },
}
```

### Loader Implementation

```rust
use std::path::Path;
use std::fs;

use crate::config::xdg;

pub struct ConfigLoader;

impl ConfigLoader {
    /// Load configuration from a specific path
    pub fn load_from_path(path: &Path) -> Result<Config, ConfigError> {
        let content = fs::read_to_string(path)
            .map_err(|e| ConfigError::ReadError {
                path: path.to_path_buf(),
                source: e,
            })?;

        toml::from_str(&content)
            .map_err(|e| ConfigError::ParseError {
                path: path.to_path_buf(),
                line: e.line_col().map(|(l, _)| l).unwrap_or(0),
                column: e.line_col().map(|(_, c)| c).unwrap_or(0),
                message: e.message().to_string(),
            })
    }

    /// Load configuration from default location, returning defaults if not found
    pub fn load_default() -> Result<Config, ConfigError> {
        let path = xdg::config_path(); // From S007.03

        if path.exists() {
            Self::load_from_path(&path)
        } else {
            Ok(Config::default())
        }
    }

    /// Load configuration, creating default file if none exists
    pub fn load_or_create_default() -> Result<Config, ConfigError> {
        let path = xdg::config_path();

        if path.exists() {
            Self::load_from_path(&path)
        } else {
            let config = Config::default();
            // Optionally create default file (S007.04)
            Ok(config)
        }
    }
}
```

### Hot-Reload Implementation

Per [Q27 decision](../epic/E007-configuration-system.md#hot-reload-scope):

```rust
use tokio::signal::unix::{signal, SignalKind};

async fn handle_sighup(daemon_state: Arc<Mutex<DaemonState>>) {
    let mut stream = signal(SignalKind::hangup()).unwrap();

    while stream.recv().await.is_some() {
        tracing::info!("Received SIGHUP, reloading configuration");

        match ConfigLoader::load_default() {
            Ok(new_config) => {
                let mut state = daemon_state.lock().unwrap();
                // Update hot-reloadable settings
                state.config.daemon.log_level = new_config.daemon.log_level;
                state.config.daemon.idle_timeout = new_config.daemon.idle_timeout;
                state.config.daemon.usage_fetch_interval = new_config.daemon.usage_fetch_interval;
                state.config.ui.tick_rate = new_config.ui.tick_rate;
                // Do NOT update socket_path or log_file (restart required)

                tracing::info!("Configuration reloaded successfully");
            }
            Err(e) => {
                tracing::error!("Failed to reload configuration: {}", e);
                // Keep old config, don't crash
            }
        }
    }
}
```

### Error Message Format

User-friendly error messages are critical for configuration issues:

```text
Error: Invalid configuration at ~/.config/agent-console/config.toml:12:5
  Invalid value for 'layout': expected one of "one-line", "two-line", "custom"

Hint: Check the configuration documentation at https://...
```

### Integration Points

The configuration should be loaded early in the startup sequence:

```rust
// In daemon main
fn main() -> Result<()> {
    let config = ConfigLoader::load_default()
        .context("Failed to load configuration")?;

    // Use config for daemon initialization
    let daemon = Daemon::new(config)?;
    daemon.run()
}

// In TUI main
fn main() -> Result<()> {
    let config = ConfigLoader::load_default()
        .context("Failed to load configuration")?;

    // Use config for TUI initialization
    let app = App::new(config)?;
    app.run()
}
```

> **Note:** The SIGHUP handler in `daemon/reload.rs` is registered in the main
> event loop (S001.01's signal handler setup). On SIGHUP, it calls
> `config::reload()` which re-reads the TOML file.

### Logging Configuration Loading

Log configuration loading for debugging:

```rust
tracing::info!("Loading configuration from {:?}", path);
tracing::debug!("Configuration loaded: {:?}", config);
```
