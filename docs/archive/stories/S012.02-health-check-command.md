# Story: Implement Health Check Command

**Story ID:** S012.02 **Epic:**
[E012 - Logging and Diagnostics](../epic/E012-logging-and-diagnostics.md)
**Status:** Draft **Priority:** P2 **Estimated Points:** 3

## Description

As a user running the daemon, I want to run `acd status` to check if the daemon
is healthy and see key metrics, So that I can quickly verify it is running and
inspect its state without parsing log files.

## Context

The daemon runs as a background process. When something seems wrong (dashboard
not updating, hooks not firing), the first diagnostic step is checking whether
the daemon is alive and responsive. The `acd status` command provides at-a-glance
health information matching the epic requirements: uptime, session count,
connection count, memory usage, and socket path.

This requires both a new CLI subcommand and a new IPC command (`STATUS`) in the
socket server protocol.

## Implementation Details

### Technical Approach

1. Add `STATUS` IPC command to the socket server that returns health data as
   JSON
2. Track daemon start time in `SocketServer` (for uptime calculation)
3. Track active connection count in daemon state
4. Use `sysinfo` crate to query memory usage (RSS)
5. Add `status` subcommand to the CLI that:
   - Connects to the daemon socket
   - Sends `STATUS` command
   - Parses the JSON response
   - Displays human-readable output
   - Exits with code 0 if healthy, 1 if daemon unreachable

### IPC Protocol

```text
STATUS
  Returns: OK <json>
  JSON payload: {
    "uptime_seconds": 9240,
    "sessions": {"active": 3, "closed": 1},
    "connections": 2,
    "memory_mb": 2.1,
    "socket_path": "/tmp/acd.sock"
  }
```

### CLI Output Format

```text
Agent Console Daemon
  Status:      running
  Uptime:      2h 34m
  Sessions:    3 active, 1 closed
  Connections: 2 dashboards
  Memory:      2.1 MB
  Socket:      /tmp/acd.sock
```

When daemon is unreachable:

```text
Agent Console Daemon
  Status:      not running
```

### Files Modified

- `crates/agent-console-dashboard/Cargo.toml` - Add `sysinfo` dependency
- `crates/agent-console-dashboard/src/main.rs` - Add `Status` subcommand
- `crates/agent-console-dashboard/src/daemon/server.rs` - Add `STATUS` command
  handler, track start time and connection count
- `crates/agent-console-dashboard/src/lib.rs` - Add `HealthStatus` response type

### Dependencies

- [S012.01 - Structured Logging](./S012.01-structured-logging.md) - Completed

## Acceptance Criteria

- [ ] `acd status` connects to daemon and displays health info
- [ ] Output includes: status, uptime, session count (active/closed), connection
      count, memory usage, socket path
- [ ] Memory usage reported via `sysinfo` crate (best-effort, "N/A" on failure)
- [ ] Exit code 0 when daemon is running, 1 when unreachable
- [ ] `STATUS` IPC command returns JSON response
- [ ] Daemon tracks start time for uptime calculation
- [ ] Daemon tracks active connection count
- [ ] `cargo test --workspace` passes
- [ ] `cargo clippy --workspace` passes

## Testing Requirements

- [ ] Unit test: `STATUS` command handler returns valid JSON
- [ ] Unit test: uptime formatting (seconds to human-readable)
- [ ] Unit test: health status response parsing
- [ ] Unit test: memory usage query (mock `sysinfo` if needed)
- [ ] Manual test: `acd status` with daemon running
- [ ] Manual test: `acd status` with daemon stopped (exit code 1)
- [ ] Manual test: verify all fields appear in output

## Out of Scope

- JSON output format flag (`--format json`) - defer to S012.03 dump command
- Historical metrics or trends
- Alerting or threshold-based warnings

## Notes

### Uptime Formatting

```rust
fn format_uptime(seconds: u64) -> String {
    let hours = seconds / 3600;
    let minutes = (seconds % 3600) / 60;
    if hours > 0 {
        format!("{}h {}m", hours, minutes)
    } else {
        format!("{}m", minutes)
    }
}
```

### Health Status Type

```rust
#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct HealthStatus {
    pub uptime_seconds: u64,
    pub sessions: SessionCounts,
    pub connections: usize,
    pub memory_mb: Option<f64>,
    pub socket_path: String,
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct SessionCounts {
    pub active: usize,
    pub closed: usize,
}
```

### Memory Usage Implementation

```rust
use sysinfo::{System, SystemExt, ProcessExt};

fn get_memory_usage() -> Option<f64> {
    let mut sys = System::new_all();
    sys.refresh_processes();

    let pid = std::process::id() as i32;
    sys.process(pid.into()).map(|proc| {
        proc.memory() as f64 / 1024.0 / 1024.0  // bytes to MB
    })
}
```

Memory measurement is best-effort. If `sysinfo` fails to query the process,
return `None` and display "N/A" in the output.

> **Note:** Socket path is hardcoded to `/tmp/agent-console.sock` in v0.
> Configurable path depends on E007 (configuration system).

> **Note:** When `memory_mb` is `Some`, display as `'{:.1} MB'` (e.g.,
> `'2.1 MB'`). When `None`, display as `'N/A'`.

> **Note:** `SessionCounts` is a shared type defined in the daemon's state
> module. Both health check and debug endpoints reference the same struct.

### Connection Tracking

Track active connections in daemon state by incrementing count on new connection
and decrementing on disconnect. This requires extending the actor model state:

```rust
struct DaemonState {
    sessions: HashMap<SessionId, Session>,
    active_connections: usize,
    start_time: SystemTime,
}
```
