# Story: Types and Errors

**Story ID:** S014.02 **Epic:** [E014 - Claude Hooks Library](../epic/E014-claude-hooks-library.md) **Status:** Done **Priority:** P0 **Estimated Points:** 2

## Description

As a developer, I want to define core domain types and error hierarchy, So that the library has a clear type system and structured error handling.

## Context

This story establishes the type foundation for claude-hooks. It defines HookEvent, HookHandler, RegistryEntry, and ListEntry types that model the domain, plus a comprehensive error hierarchy using thiserror. These types are used by all subsequent stories.

Design decisions implemented: D22 (composite key identity), D34 (command format), D24 (installed_by free-form string).

## Implementation Details

### Technical Approach

1. Add dependencies: `thiserror`, `serde`, `serde_json`, `chrono`
2. Create `src/types.rs` with domain types (HookEvent, HookHandler, etc.)
3. Create `src/error.rs` with error hierarchy (thiserror-based)
4. Implement serialization/deserialization for all types
5. Add helper methods (e.g., `RegistryEntry::matches()`)
6. Write unit tests for type roundtrip and event string mapping

### Files to Create

- `src/types.rs` - Core domain types
- `src/error.rs` - Error hierarchy with thiserror

### Files to Modify

- `Cargo.toml` - Add dependencies (thiserror, serde, serde_json, chrono)
- `src/lib.rs` - Re-export types and errors

### Dependencies

- S014.01 (scaffold crate)

## Acceptance Criteria

- [x] Given HookEvent enum, when serialized, then it matches Claude's event names ("Start", "Stop", etc.)
- [x] Given HookHandler struct, when serialized, then it matches Claude's settings.json structure
- [x] Given RegistryEntry struct, when created, then it contains all identity and metadata fields
- [x] Given ListEntry struct, when created, then it includes managed flag and optional metadata
- [x] Given error types, when displayed, then they show clear context (paths, hook identity)
- [x] Given all types, when serialized and deserialized, then roundtrip succeeds
- [x] Given RegistryEntry, when calling matches(), then it correctly identifies hook by composite key

## Testing Requirements

- [x] Unit test: HookEvent serialization to string ("Start", "Stop", etc.)
- [x] Unit test: HookEvent deserialization from string
- [x] Unit test: HookHandler serialization roundtrip
- [x] Unit test: RegistryEntry serialization roundtrip
- [x] Unit test: RegistryEntry::matches() with same event+command returns true
- [x] Unit test: RegistryEntry::matches() with different command returns false
- [x] Unit test: Error display includes context (paths, hook identity)

## Out of Scope

- File I/O operations (S014.03, S014.04)
- Public API implementation (S014.05)
- Integration tests (S014.06)

## Notes

### Dependencies to Add

```toml
[dependencies]
thiserror = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
chrono = "0.4"
```

### HookEvent Enum

```rust
/// Claude Code hook events
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum HookEvent {
    Start,
    Stop,
    BeforePrompt,
    AfterPrompt,
    BeforeToolUse,
    AfterToolUse,
    BeforeEdit,
    AfterEdit,
    BeforeRevert,
    AfterRevert,
    BeforeRun,
    AfterRun,
}
```

Serializes to exact Claude strings: `"Start"`, `"Stop"`, `"BeforePrompt"`, etc.

### HookHandler Struct

```rust
/// Hook handler configuration (matches Claude's settings.json structure)
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct HookHandler {
    pub r#type: String,           // "command" in v0.1
    pub command: String,          // Full command string with args
    pub matcher: String,          // Empty string for global hooks
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<u32>,     // Optional timeout in seconds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#async: Option<bool>,    // Optional async flag
}
```

### RegistryEntry Struct

```rust
/// Registry entry (internal representation with metadata)
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct RegistryEntry {
    // Identity fields (composite key - D22)
    pub event: HookEvent,
    pub matcher: String,
    pub r#type: String,
    pub command: String,

    // Configuration fields (not part of identity)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#async: Option<bool>,

    // Metadata fields
    pub scope: String,              // "user" in v0.1
    pub enabled: bool,              // Always true in v0.1
    pub added_at: String,           // Timestamp (yyyyMMdd-hhmmss)
    pub installed_by: String,       // Free-form string (D24)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

impl RegistryEntry {
    /// Check if this entry matches the given event and command (composite key)
    pub fn matches(&self, event: HookEvent, command: &str) -> bool {
        self.event == event && self.command == command
    }
}
```

### ListEntry Struct

```rust
/// Entry returned by list() function
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ListEntry {
    pub event: HookEvent,
    pub handler: HookHandler,
    pub managed: bool,                      // True if we installed it
    pub metadata: Option<RegistryMetadata>, // Present if managed
}

/// Subset of registry metadata for list output
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct RegistryMetadata {
    pub added_at: String,
    pub installed_by: String,
    pub description: Option<String>,
    pub reason: Option<String>,
    pub optional: Option<bool>,
}
```

### Error Hierarchy

```rust
use thiserror::Error;
use std::path::PathBuf;

/// Top-level error type
#[derive(Debug, Error)]
pub enum Error {
    #[error(transparent)]
    Settings(#[from] SettingsError),

    #[error(transparent)]
    Registry(#[from] RegistryError),

    #[error(transparent)]
    Hook(#[from] HookError),
}

/// Settings file errors
#[derive(Debug, Error)]
pub enum SettingsError {
    #[error("Settings file not found: {0}")]
    NotFound(PathBuf),

    #[error("Failed to read settings: {0}")]
    Io(#[source] std::io::Error),

    #[error("Failed to parse settings: {0}")]
    Parse(String),

    #[error("Failed to write settings atomically: {path} - Safety copy at: {temp_path}")]
    WriteAtomic {
        path: PathBuf,
        temp_path: PathBuf,
    },
}

/// Registry errors
#[derive(Debug, Error)]
pub enum RegistryError {
    #[error("Failed to read registry: {0}")]
    Io(#[source] std::io::Error),

    #[error("Failed to parse registry: {0}")]
    Parse(String),

    #[error("Failed to write registry: {0}")]
    Write(String),
}

/// Hook logic errors
#[derive(Debug, Error)]
pub enum HookError {
    #[error("Hook already exists: {event:?} - {command}")]
    AlreadyExists {
        event: HookEvent,
        command: String,
    },

    #[error("Hook not managed by claude-hooks: {event:?} - {command}")]
    NotManaged {
        event: HookEvent,
        command: String,
    },

    #[error("Invalid hook handler: {0}")]
    InvalidHandler(String),
}

/// Result type alias
pub type Result<T> = std::result::Result<T, Error>;
```

### Re-exports in lib.rs

```rust
mod types;
mod error;

// Re-export all public types
pub use types::{HookEvent, HookHandler, RegistryEntry, ListEntry, RegistryMetadata};
pub use error::{Error, SettingsError, RegistryError, HookError, Result};
```

### Example Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hook_event_serialization() {
        let event = HookEvent::Stop;
        let json = serde_json::to_string(&event).unwrap();
        assert_eq!(json, r#""Stop""#);
    }

    #[test]
    fn test_hook_event_deserialization() {
        let json = r#""Start""#;
        let event: HookEvent = serde_json::from_str(json).unwrap();
        assert_eq!(event, HookEvent::Start);
    }

    #[test]
    fn test_hook_handler_roundtrip() {
        let handler = HookHandler {
            r#type: "command".to_string(),
            command: "/path/to/stop.sh".to_string(),
            matcher: String::new(),
            timeout: Some(600),
            r#async: None,
        };
        let json = serde_json::to_string(&handler).unwrap();
        let deserialized: HookHandler = serde_json::from_str(&json).unwrap();
        assert_eq!(handler, deserialized);
    }

    #[test]
    fn test_registry_entry_matches() {
        let entry = RegistryEntry {
            event: HookEvent::Stop,
            matcher: String::new(),
            r#type: "command".to_string(),
            command: "/path/to/stop.sh".to_string(),
            timeout: None,
            r#async: None,
            scope: "user".to_string(),
            enabled: true,
            added_at: "20260203-143022".to_string(),
            installed_by: "acd".to_string(),
            description: None,
            reason: None,
            optional: None,
        };

        assert!(entry.matches(HookEvent::Stop, "/path/to/stop.sh"));
        assert!(!entry.matches(HookEvent::Stop, "/different/path"));
        assert!(!entry.matches(HookEvent::Start, "/path/to/stop.sh"));
    }
}
```


## Dev Agent Record

**Implemented:** 2026-02-03

### Implementation Summary

Created core type system and error hierarchy for claude-hooks v0.1:

**Files Created:**
- `src/error.rs` - Error hierarchy with thiserror (Error, SettingsError, RegistryError, HookError)
- `src/types.rs` - Domain types (HookEvent, HookHandler, RegistryEntry, ListEntry, RegistryMetadata)

**Files Modified:**
- `Cargo.toml` - Added dependencies: thiserror, serde, serde_json, chrono
- `src/lib.rs` - Re-exported all public types and errors

### Test Coverage

12 unit tests covering:
- HookEvent serialization/deserialization for all 12 event types
- HookHandler roundtrip with optional fields
- RegistryEntry roundtrip and composite key matching
- Error display with context (paths, hook identity)

All tests pass: `cargo test -p claude-hooks` (12 passed)

### Design Decisions Applied

- D22: Hook identity as composite key (event, matcher, type, command)
- D24: installed_by as free-form string
- D34: Command field is full command string with arguments
- Used `#[serde(rename)]` for rust keywords (r#type, r#async)
- Used `#[serde(skip_serializing_if = "Option::is_none")]` for optional fields

### File List

- crates/claude-hooks/Cargo.toml
- crates/claude-hooks/src/error.rs
- crates/claude-hooks/src/types.rs
- crates/claude-hooks/src/lib.rs
