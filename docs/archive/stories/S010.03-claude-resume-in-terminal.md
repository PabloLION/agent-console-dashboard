# Story: Execute claude --resume in Terminal/Pane

**Story ID:** S010.03 **Epic:**
[E010 - Zellij Integration](../epic/E010-zellij-integration.md)
**Status:** Draft **Priority:** P2 **Estimated Points:** 2

## Description

As a developer, I want the system to execute `claude --resume <session-id>` in the appropriate terminal context, So that session resurrection works seamlessly whether in Zellij, tmux, or a plain terminal.

## Context

This story was moved from E008 (where it was S008.03) to E010 because executing commands in terminals/panes is a multiplexer integration concern, not a protocol concern. E008 provides the RESURRECT IPC command and session metadata; this story handles the actual terminal execution.

The implementation provides a unified interface for terminal command execution that abstracts over different environments (Zellij, tmux, plain terminal).

## Implementation Details

### Technical Approach

1. Create a terminal abstraction module that detects the current environment
2. Implement environment-specific command execution:
   - Zellij: `zellij action new-pane -- <command>`
   - Plain terminal: Display command for user to copy
   - (Future: tmux support)
3. Provide a single `execute_in_terminal(cmd, args)` function
4. Handle working directory context for `claude --resume`
5. Return result indicating success/failure and any user-facing messages

### Files to Create

- `crates/agent-console-dashboard/src/terminal/mod.rs` - Terminal abstraction module
- `crates/agent-console-dashboard/src/terminal/environment.rs` - Environment detection
- `crates/agent-console-dashboard/src/terminal/executor.rs` - Command execution logic

### Files to Modify

- `crates/agent-console-dashboard/src/lib.rs` - Export terminal module
- `crates/agent-console-dashboard/src/tui/handlers.rs` - Use terminal executor for resurrection

### Dependencies

- S008.01: Closed session metadata (provides working directory and session ID)
- S008.02: RESURRECT IPC command (protocol for resurrection)
- S010.01: Zellij layout integration (base)

## Acceptance Criteria

- [ ] Given Zellij environment, when `execute_in_terminal` is called, then new pane is created with command
- [ ] Given plain terminal, when `execute_in_terminal` is called, then command is returned for user to copy
- [ ] Given command execution succeeds, when result is returned, then success status is indicated
- [ ] Given command execution fails, when result is returned, then error details are provided
- [ ] Given session working directory, when resurrection command is built, then `cd <dir> && claude --resume <id>` pattern is used
- [ ] Given environment detection, when `$ZELLIJ` is set, then Zellij mode is detected

## Testing Requirements

- [ ] Unit test: Environment detection identifies Zellij via `$ZELLIJ`
- [ ] Unit test: Environment detection identifies plain terminal
- [ ] Unit test: Command string builder generates correct arguments
- [ ] Manual test: Zellij pane creation works
- [ ] Manual test: Fallback display works in plain terminal

## Out of Scope

- tmux integration (deferred to future story)
- Clipboard integration for command copy
- iTerm2/Terminal.app-specific integrations
- Windows terminal integration

## Notes

### Terminal Environment Enum

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TerminalEnvironment {
    Zellij,
    Tmux,
    Plain,
}

impl TerminalEnvironment {
    pub fn detect() -> Self {
        if std::env::var("ZELLIJ").is_ok() {
            Self::Zellij
        } else if std::env::var("TMUX").is_ok() {
            Self::Tmux
        } else {
            Self::Plain
        }
    }
}
```

### Execution Result

```rust
#[derive(Debug)]
pub enum ExecutionResult {
    /// Command was executed successfully in a pane/terminal
    Executed,

    /// Command could not be executed; user should run it manually
    DisplayCommand(String),

    /// Execution failed with error
    Failed(String),
}
```

### Terminal Executor

```rust
// src/terminal/executor.rs

use std::path::Path;
use std::process::Command;

pub fn execute_in_terminal(
    cmd: &str,
    args: &[String],
    working_dir: Option<&Path>,
) -> Result<ExecutionResult, TerminalError> {
    let env = TerminalEnvironment::detect();

    match env {
        TerminalEnvironment::Zellij => execute_zellij_pane(cmd, args, working_dir),
        TerminalEnvironment::Tmux => {
            unimplemented!("tmux support deferred per Q9 — on request only")
        }
        TerminalEnvironment::Plain => {
            Ok(ExecutionResult::DisplayCommand(build_command_string(cmd, args, working_dir)))
        }
    }
}

fn execute_zellij_pane(
    cmd: &str,
    args: &[String],
    working_dir: Option<&Path>,
) -> Result<ExecutionResult, TerminalError> {
    let mut command = Command::new("zellij");
    command.args(["action", "new-pane", "--"]);

    // Use sh -c "cd <dir> && cmd args" pattern for working directory
    if let Some(dir) = working_dir {
        let full_cmd = format!("cd {} && {} {}", dir.display(), cmd, args.join(" "));
        command.args(["action", "new-pane", "--"]);
        command.args(["sh", "-c", &full_cmd]);
    } else {
        command.arg(cmd);
        command.args(args);
    }

    let status = command.status()
        .map_err(|e| TerminalError::ExecutionFailed(e.to_string()))?;

    if status.success() {
        Ok(ExecutionResult::Executed)
    } else {
        Ok(ExecutionResult::Failed("Zellij pane creation failed".to_string()))
    }
}

fn build_command_string(cmd: &str, args: &[String], working_dir: Option<&Path>) -> String {
    let mut parts = vec![cmd.to_string()];
    parts.extend_from_slice(args);

    if let Some(dir) = working_dir {
        format!("cd {} && {}", dir.display(), parts.join(" "))
    } else {
        parts.join(" ")
    }
}
```

### Usage in Resurrection Handler

```rust
// In TUI resurrection handler

use crate::terminal::{execute_in_terminal, ExecutionResult};

fn handle_resurrection(&mut self, session_id: &str, working_dir: &Path) -> Result<()> {
    let args = vec![
        "--resume".to_string(),
        session_id.to_string(),
    ];

    match execute_in_terminal("claude", &args, Some(working_dir))? {
        ExecutionResult::Executed => {
            self.send_resurrect_command(session_id)?;
            self.status_line = "Resurrecting session in new pane".to_string();
        }
        ExecutionResult::DisplayCommand(cmd) => {
            self.status_line = format!("Run: {}", cmd);
        }
        ExecutionResult::Failed(err) => {
            self.status_line = format!("Error: {}", err);
        }
    }

    Ok(())
}
```

### Error Types

```rust
#[derive(Debug, thiserror::Error)]
pub enum TerminalError {
    #[error("Failed to execute command: {0}")]
    ExecutionFailed(String),

    #[error("Unsupported terminal environment")]
    UnsupportedEnvironment,
}
```

### Future: tmux Support

When implementing tmux support, add:

```rust
fn execute_tmux_pane(
    cmd: &str,
    args: &[String],
    working_dir: Option<&Path>,
) -> Result<ExecutionResult, TerminalError> {
    // Use tmux split-window or new-window
    // tmux split-window -h "cd <dir> && claude --resume <session-id>"
    unimplemented!("tmux support deferred per Q9 — on request only")
}
```

> **Note:** Always use `cd` before running `claude` in interactive mode. The
> `--cwd` flag is only for programmatic/headless use.

### Integration with S010.02

S010.02 (Zellij Resurrection Workflow) uses this module's `execute_in_terminal` function to actually perform the terminal command execution. S010.02 focuses on the workflow and UI aspects; S010.03 provides the terminal execution primitive.
