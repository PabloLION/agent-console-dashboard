# Story: Add Structured Logging to Daemon

**Story ID:** S012.01 **Epic:**
[E012 - Logging and Diagnostics](../epic/E012-logging-and-diagnostics.md)
**Status:** Done **Priority:** P1 **Estimated Points:** 2

## Description

As a developer running the daemon, I want structured log output with
configurable levels and dual-format support, So that I can diagnose issues
during development (human-readable stderr) and in production (JSON log files).

## Context

The daemon requires logging for observability as a long-running background
process. Per the epic, this story implements the foundation: `tracing` crate
setup, configurable log levels via `ACD_LOG` environment variable, and
dual-format output (human-readable for foreground, JSON for background).

## Implementation Details

### Technical Approach

1. Add `tracing-subscriber` dependency with `env-filter`, `fmt`, and `json`
   features
2. Create `logging::init()` function that configures dual-layer subscriber:
   - `fmt::Layer` for human-readable stderr output (foreground mode)
   - `json::Layer` for structured file output (background mode)
3. Read `ACD_LOG` env var for log level (default: `info`)
4. Log file location: `$XDG_STATE_HOME/agent-console/acd.log` (default:
   `~/.local/state/agent-console/acd.log`)
5. Create log directory if it doesn't exist (mode `0700`)
6. Create log file with mode `0600` (owner read/write only)
7. Call `logging::init()` at the top of `run_daemon()` before any other work

### Files Modified

- `crates/agent-console-dashboard/Cargo.toml` - Add `tracing-subscriber`
  dependency
- `crates/agent-console-dashboard/src/daemon/mod.rs` - Add `logging` submodule,
  call `init()`
- `crates/agent-console-dashboard/src/daemon/logging.rs` - New file: subscriber
  initialization

### Log Format Examples

**Foreground (stderr, human-readable):**

```text
2026-01-31T12:00:00 INFO session status updated session_id=abc123 status=Working
2026-01-31T12:00:05 WARN failed to process hook command error="invalid session id"
```

**Background (file, JSON structured):**

```json
{"ts":"2026-01-31T12:00:00Z","level":"info","msg":"session status updated","session_id":"abc123","status":"Working"}
{"ts":"2026-01-31T12:00:05Z","level":"warn","msg":"failed to process hook command","error":"invalid session id"}
```

### Dependencies

- None (E001 daemon infrastructure already exists)

## Acceptance Criteria

- [x] `tracing-subscriber` added with `env-filter`, `fmt`, and `json` features
- [x] `ACD_LOG=debug acd daemon` produces debug-level output to stderr
- [x] Default log level is `info` when `ACD_LOG` is not set
- [x] Foreground mode (stderr) uses human-readable format
- [x] Background mode (file) uses JSON format with structured fields
- [x] Log file location: `$XDG_STATE_HOME/agent-console/acd.log`
- [x] Log directory created with mode `0700` if it doesn't exist
- [x] Log file created with mode `0600` (owner read/write only)
- [x] Daemon startup logs socket path and mode at `info` level
- [x] Shutdown signal logged at `info` level
- [x] `cargo test --workspace` passes
- [x] `cargo clippy --workspace` passes

## Testing Requirements

- [x] Unit test: `logging::init()` does not panic
- [x] Unit test: verify `EnvFilter` parses valid directives
- [x] Manual test: run `acd daemon` and observe info-level startup log
- [x] Manual test: run `ACD_LOG=debug acd daemon` and observe debug output
- [x] Manual test: verify log file contains JSON-formatted entries
- [x] Manual test: verify log file has mode `0600` permissions

## Out of Scope

- Configuration file support for log level and path (requires E007)
- Log rotation (use OS tools: `logrotate`, `newsyslog`)
- Remote logging or metrics export (deferred to v2+)
- Hot-reload of log level (requires config hot-reload from E007)

## Notes

### Subscriber Configuration

```rust
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use std::path::PathBuf;

pub fn init(log_file: Option<PathBuf>) -> Result<()> {
    let filter = EnvFilter::try_from_env("ACD_LOG")
        .unwrap_or_else(|_| EnvFilter::new("info"));

    let stderr_layer = fmt::layer()
        .with_target(false)
        .with_writer(std::io::stderr);

    if let Some(path) = log_file {
        // Background mode: add JSON file layer
        let file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .mode(0o600)
            .open(&path)?;

        let file_layer = fmt::layer()
            .json()
            .with_writer(file);

        tracing_subscriber::registry()
            .with(filter)
            .with(stderr_layer)
            .with(file_layer)
            .init();
    } else {
        // Foreground mode: stderr only
        tracing_subscriber::registry()
            .with(filter)
            .with(stderr_layer)
            .init();
    }

    Ok(())
}
```

### Log Level Mapping

| Level | What gets logged                                       |
| ----- | ------------------------------------------------------ |
| error | Fatal conditions, bugs                                 |
| warn  | Client handler errors, SIGTERM handler failures        |
| info  | Startup, shutdown, socket binding, connection events   |
| debug | Client connects/disconnects, command processing        |
| trace | Raw IPC message content (for deep debugging)           |

### XDG State Directory Resolution

```rust
fn log_file_path() -> PathBuf {
    let base = std::env::var("XDG_STATE_HOME")
        .map(PathBuf::from)
        .unwrap_or_else(|_| {
            let home = std::env::var("HOME").expect("HOME not set");
            PathBuf::from(home).join(".local/state")
        });

    base.join("agent-console").join("acd.log")
}
```

### Log File Permissions Rationale

Log files use mode `0600` (owner read/write only) because they may contain
session IDs and working directory paths. This prevents other users from reading
sensitive information about active development sessions.
