# Story: Implement API Usage Widget

**Story ID:** S005.04 **Epic:**
[E005 - Widget System](../epic/E005-widget-system.md) **Status:** Draft
**Priority:** P2 **Estimated Points:** 2

## Description

As a user, I want an api-usage widget in the dashboard, So that I can see my
account-level quota utilization at a glance.

## Context

The api-usage widget renders account-level 5h and 7d quota utilization provided
via `WidgetContext.usage`. The daemon fetches this data from the `claude-usage`
crate every 3 minutes and broadcasts it to all subscribed TUIs (see
[widget data flow](../architecture/widget-data-flow.md)).

This widget is a **stateless renderer** that reads `UsageData` from
`WidgetContext` and formats it for display. It must never call
`claude_usage::get_usage()` directly. The daemon owns all data fetching.

## Implementation Details

### Technical Approach

1. Create `crates/agent-console-dashboard/src/widgets/api_usage.rs`
2. Implement Widget trait for ApiUsageWidget
3. Read `UsageData` from `WidgetContext`
4. Render 5h/7d quota percentages with color coding
5. Support compact and full display modes based on width
6. Show placeholder when data status is Unavailable

### Files to Modify

- `crates/agent-console-dashboard/src/widgets/api_usage.rs` - ApiUsageWidget
  implementation
- `crates/agent-console-dashboard/src/widgets/mod.rs` - export and register
  api-usage widget

### Dependencies

- [S005.01 - Widget Trait/Interface](./S005.01-widget-trait-interface.md) -
  Widget trait to implement
- [E009 - API Usage Tracking](../epic/E009-api-usage-tracking.md) - UsageData
  type definition (daemon fetches from claude-usage crate)

## Acceptance Criteria

- [ ] Given usage data is available in `WidgetContext`, when widget renders,
      then 5h and 7d utilization percentages are displayed
- [ ] Given terminal width is 30+ columns, when widget renders, then full format
      is used: `Quota: 5h 8% | 7d 77% | resets 2h 15m`
- [ ] Given terminal width is under 30 columns, when widget renders, then
      compact format is used: `[5h:8% 7d:77%]`
- [ ] Given usage data status is Unavailable, when widget renders, then
      `Quota: --` placeholder is shown
- [ ] Given 5h utilization exceeds 80%, when widget renders, then yellow color
      is applied
- [ ] Given 5h utilization exceeds 95%, when widget renders, then red color is
      applied
- [ ] Given the widget is registered, when layout includes `api-usage`, then it
      renders correctly in all presets
- [ ] Given the widget renders, when called, then it MUST NOT make external API
      calls (all data from WidgetContext)

## Testing Requirements

- [ ] Unit test: Full format renders correct string for sample UsageData
- [ ] Unit test: Compact format renders correct string
- [ ] Unit test: Placeholder displays when status is Unavailable
- [ ] Unit test: Width constraint selects correct format
- [ ] Unit test: Color thresholds apply correctly (green/yellow/red)
- [ ] Unit test: Widget never calls claude_usage::get_usage()

## Out of Scope

- Per-session token tracking (no data source available)
- USD cost estimates (removed per E009 revision)
- Historical usage graphs
- Usage alerts or notifications
- Token count display (replaced by quota percentages)
- Direct API calls (daemon owns all fetching)

## Notes

### Data Flow Architecture

```text
claude-usage crate → daemon (fetches every 3 min) → broadcast to TUIs
                                                    → WidgetContext.usage
                                                    → api-usage widget
```

The widget is a pure renderer. It MUST NOT call `claude_usage::get_usage()`
directly. See [widget data flow](../architecture/widget-data-flow.md) and
[discussion decisions D3/D4](../architecture/2026-01-31-discussion-decisions.md).

### Implementation

```rust
use ratatui::prelude::*;
use crate::widgets::{Widget, WidgetContext};
use crate::usage::UsageData;

pub struct ApiUsageWidget;

impl ApiUsageWidget {
    pub fn new() -> Self {
        Self
    }

    fn format_full(&self, usage: &UsageData) -> Line<'_> {
        let h5 = usage.five_hour.utilization;
        let d7 = usage.seven_day.utilization;
        let reset = format_reset_time(usage.five_hour.resets_at);

        let h5_color = utilization_color(h5);
        let d7_color = utilization_color(d7);

        Line::from(vec![
            Span::raw("Quota: 5h "),
            Span::styled(
                format!("{:.0}%", h5),
                Style::default().fg(h5_color),
            ),
            Span::raw(" | 7d "),
            Span::styled(
                format!("{:.0}%", d7),
                Style::default().fg(d7_color),
            ),
            Span::raw(&format!(" | resets {}", reset)),
        ])
    }

    fn format_compact(&self, usage: &UsageData) -> Line<'_> {
        let h5 = usage.five_hour.utilization;
        let d7 = usage.seven_day.utilization;

        Line::from(vec![
            Span::raw("[5h:"),
            Span::styled(
                format!("{:.0}%", h5),
                Style::default().fg(utilization_color(h5)),
            ),
            Span::raw(" 7d:"),
            Span::styled(
                format!("{:.0}%", d7),
                Style::default().fg(utilization_color(d7)),
            ),
            Span::raw("]"),
        ])
    }
}

fn utilization_color(pct: f64) -> Color {
    if pct > 95.0 {
        Color::Red
    } else if pct > 80.0 {
        Color::Yellow
    } else {
        Color::Green
    }
}

impl Widget for ApiUsageWidget {
    fn render(&self, width: u16, context: &WidgetContext) -> Line<'_> {
        match context.usage.status {
            DataStatus::Ok => {
                if width < 30 {
                    self.format_compact(context.usage)
                } else {
                    self.format_full(context.usage)
                }
            }
            DataStatus::Unavailable => Line::from(Span::styled(
                "Quota: --",
                Style::default().fg(Color::DarkGray),
            )),
        }
    }

    fn id(&self) -> &'static str {
        "api-usage"
    }

    fn min_width(&self) -> u16 {
        18
    }
}
```

### Color Thresholds

| Utilization | Color  |
| ----------- | ------ |
| < 80%       | Green  |
| 80% - 95%   | Yellow |
| > 95%       | Red    |

Thresholds match E009 API Usage Tracking epic for consistency.

### Reset Time Formatting

```rust
fn format_reset_time(resets_at: DateTime<Utc>) -> String {
    let now = Utc::now();
    let duration = resets_at - now;

    let hours = duration.num_hours();
    let minutes = (duration.num_minutes() % 60).abs();

    format!("{}h {}m", hours, minutes)
}
```

### Display Examples

**Full format (width >= 30):**

```text
Quota: 5h 8% | 7d 77% | resets 2h 15m
```

**Compact format (width < 30):**

```text
[5h:8% 7d:77%]
```

**Unavailable (fetch failed):**

```text
Quota: --
```

### Relationship to E009

E009 defines the daemon's usage fetching logic and data model. This story
implements the widget renderer that displays that data. The split exists because
E005 owns widget architecture and E009 owns usage tracking logic.

The daemon (E009) calls `claude_usage::get_usage()` every 3 minutes and
broadcasts `UsageData` to all TUIs. This widget (E005) reads that data from
`WidgetContext` and renders it.
