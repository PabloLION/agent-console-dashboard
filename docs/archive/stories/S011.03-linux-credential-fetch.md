# Story: Linux Credential File Fetch

**Story ID:** S011.03 **Epic:**
[E011 - Claude Usage Crate](../epic/E011-claude-usage-crate.md) **Status:** Done
**Priority:** P1 **Estimated Points:** 2

## Description

As a Linux user, I want the `claude-usage` crate to fetch OAuth credentials from the credential file, So that I can retrieve my API usage without manually providing credentials.

## Context

On Linux, Claude Code stores OAuth credentials in a JSON file at `~/.claude/.credentials.json`. The format is identical to the macOS Keychain value. This story implements credential retrieval for Linux systems, with environment variable override support.

## Implementation Details

### Technical Approach

1. Check `CLAUDE_CODE_OAUTH_TOKEN` environment variable first (takes precedence)
2. If not set, read file from `~/.claude/.credentials.json`
3. Parse JSON to extract `claudeAiOauth.accessToken` (share parsing logic with macOS)
4. Check `expiresAt` to detect expired tokens
5. Return token or appropriate error
6. Handle file permission errors gracefully

### Credential Location

```text
~/.claude/.credentials.json
```

### Files to Create

- `crates/claude-usage/src/credentials/linux.rs` - Linux file implementation

### Files to Modify

- `crates/claude-usage/src/credentials/mod.rs` - Add Linux platform support
- `crates/claude-usage/src/credentials/common.rs` - Shared JSON parsing logic

### Dependencies

- S011.01: Workspace restructure
- S011.02: macOS implementation (shares parsing logic and error types)

## Acceptance Criteria

- [ ] Given valid credential file, when `get_token()` is called, then access token is returned
- [ ] Given `CLAUDE_CODE_OAUTH_TOKEN` env var set, when `get_token()` is called, then env var value is used (skips file read)
- [ ] Given missing credential file, when `get_token()` is called, then `CredentialNotFound` error is returned
- [ ] Given unreadable file (permissions), when `get_token()` is called, then `Permission` error is returned
- [ ] Given expired credentials, when `get_token()` is called, then `TokenExpired` error is returned
- [ ] Given malformed JSON, when `get_token()` is called, then `Parse` error is returned

## Testing Requirements

- [ ] Unit test: Environment variable takes precedence over file
- [ ] Unit test: Parse valid credential JSON correctly (shared with macOS)
- [ ] Unit test: Handle missing file gracefully
- [ ] Unit test: Handle permission errors
- [ ] Manual test: Read real credential file (requires Claude Code installed on Linux)

## Out of Scope

- secret-service/libsecret integration (may add in future)
- Token refresh
- Writing credentials to file
- File encryption

## Notes

### Implementation

```rust
// crates/claude-usage/src/credentials/linux.rs

use std::fs;
use std::path::PathBuf;
use super::common::parse_credential_json;

pub fn get_token_linux() -> Result<String, CredentialError> {
    // Check environment variable first
    if let Ok(token) = std::env::var("CLAUDE_CODE_OAUTH_TOKEN") {
        return Ok(token);
    }

    // Read from file
    let path = get_credentials_path()?;
    let content = fs::read_to_string(&path)
        .map_err(|e| match e.kind() {
            std::io::ErrorKind::NotFound => CredentialError::NotFound,
            std::io::ErrorKind::PermissionDenied => {
                CredentialError::Permission(path.display().to_string())
            }
            _ => CredentialError::Io(e.to_string()),
        })?;

    // Parse using shared logic
    parse_credential_json(&content)
}

fn get_credentials_path() -> Result<PathBuf, CredentialError> {
    let home = std::env::var("HOME")
        .map_err(|_| CredentialError::NoHomeDir)?;
    Ok(PathBuf::from(home).join(".claude/.credentials.json"))
}
```

### Shared Parsing Logic

```rust
// crates/claude-usage/src/credentials/common.rs

use serde_json::Value;

/// Parse credential JSON and extract access token
/// Shared between macOS and Linux implementations
pub(crate) fn parse_credential_json(content: &str) -> Result<String, CredentialError> {
    let json: Value = serde_json::from_str(content)
        .map_err(|e| CredentialError::Parse(e.to_string()))?;

    let oauth = json.get("claudeAiOauth")
        .ok_or(CredentialError::MissingField("claudeAiOauth"))?;

    // Check expiration
    if let Some(expires_at) = oauth.get("expiresAt").and_then(|v| v.as_i64()) {
        let now_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as i64;

        if now_ms > expires_at {
            return Err(CredentialError::Expired);
        }
    }

    // Extract token
    let token = oauth.get("accessToken")
        .and_then(|v| v.as_str())
        .ok_or(CredentialError::MissingField("accessToken"))?;

    Ok(token.to_string())
}
```

### Error Types (Extended)

```rust
#[derive(Debug, thiserror::Error)]
pub enum CredentialError {
    #[error("Claude Code credentials not found. Run `claude` to login.")]
    NotFound,

    #[error("Credentials expired. Run `claude` to re-login.")]
    Expired,

    #[error("Failed to parse credentials: {0}")]
    Parse(String),

    #[error("Missing field in credentials: {0}")]
    MissingField(&'static str),

    #[error("Permission denied reading credentials from {0}")]
    Permission(String),

    #[error("IO error: {0}")]
    Io(String),

    #[error("HOME environment variable not set")]
    NoHomeDir,
}
```

### Security Note

The Linux credential file is less secure than macOS Keychain (plain file on disk). Users should ensure proper file permissions (600). The crate follows the same security practices: read → use → discard immediately, no logging, no retention.

### Environment Variable Override

The `CLAUDE_CODE_OAUTH_TOKEN` environment variable is useful for:
- CI/CD environments
- Testing
- Manual credential injection

It takes precedence over the file to support these use cases.
