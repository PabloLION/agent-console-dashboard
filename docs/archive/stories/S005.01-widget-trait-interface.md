# Story: Create Widget Trait/Interface

**Story ID:** S005.01 **Epic:**
[E005 - Widget System](../epic/E005-widget-system.md) **Status:** Draft
**Priority:** P1 **Estimated Points:** 5

## Description

As a developer, I want to create a widget trait that defines the interface for
all UI widgets, So that all widgets have a consistent contract for rendering and
configuration.

## Context

The Agent Console Dashboard uses a widget-based architecture where each line in
the display is a widget. This trait defines the fundamental contract that all
widgets must implement: rendering output, providing an identifier for
configuration, and specifying minimum width requirements.

The widget system enables users to compose custom layouts by selecting and
ordering widgets. A consistent interface ensures widgets can be dynamically
selected, configured, and rendered by the layout system.

**Critical:** Widgets are stateless renderers that follow the centralized data
flow architecture. All data comes via `WidgetContext` (populated from daemon
broadcasts). Widgets must never make external API calls or maintain internal
state. See [widget data flow](../architecture/widget-data-flow.md).

## Implementation Details

### Technical Approach

1. Create `crates/agent-console-dashboard/src/widgets/mod.rs` as the widget
   module entry point
2. Define the `Widget` trait with required methods
3. Define `WidgetContext` struct to provide shared state to widgets
4. Create widget registry for dynamic widget lookup by ID
5. Implement widget factory function for configuration-based instantiation
6. Add support for widget styling via Ratatui's `Line` and `Span` types

### Files to Modify

- `crates/agent-console-dashboard/src/widgets/mod.rs` - Widget trait definition,
  registry, and exports
- `crates/agent-console-dashboard/src/widgets/context.rs` - WidgetContext struct
  with shared state
- `crates/agent-console-dashboard/src/lib.rs` - Add widgets module export

### Dependencies

- [S004.01 - Ratatui Application Scaffold](./S004.01-ratatui-application-scaffold.md) -
  Provides Ratatui types for styled output
- [S002.01 - Session Data Model](./S002.01-session-data-model.md) - Session data
  needed by session-status widget
- [E009 - API Usage Tracking](../epic/E009-api-usage-tracking.md) - UsageData
  type for api-usage widget

## Acceptance Criteria

- [ ] Given a Widget trait is defined, when a struct implements it, then it must
      provide `render()`, `id()`, and `min_width()` methods
- [ ] Given the `render()` method is called, when provided width and context,
      then it returns a styled `Line` for display
- [ ] Given a widget ID, when looked up in the registry, then the corresponding
      widget factory is returned
- [ ] Given the `min_width()` is queried, when terminal is narrower, then layout
      system can decide to hide widget
- [ ] Given WidgetContext is passed to render, when widget needs session data,
      then it can access current sessions
- [ ] Given WidgetContext is passed to render, when widget needs usage data,
      then it can access UsageData from daemon broadcasts
- [ ] Given WidgetContext is passed to render, when widget needs time, then it
      can access current timestamp
- [ ] Given a widget is implemented, when it needs data, then it MUST only read
      from WidgetContext (no external API calls)

## Testing Requirements

- [ ] Unit test: Widget trait can be implemented by a mock widget
- [ ] Unit test: Widget registry returns correct factory for known IDs
- [ ] Unit test: Widget registry returns None for unknown IDs
- [ ] Unit test: WidgetContext provides access to session data
- [ ] Unit test: WidgetContext provides access to usage data

## Out of Scope

- Implementing actual widgets (S005.02-S005.04)
- Layout preset system (S005.05)
- Widget configuration from TOML (E007)
- Widget orientation modes (vertical/horizontal)

## Notes

### Widget Trait Definition

```rust
use ratatui::text::Line;

/// Context passed to widgets during rendering
pub struct WidgetContext<'a> {
    /// Current sessions to display
    pub sessions: &'a [Session],
    /// Current timestamp for time-based widgets
    pub now: chrono::DateTime<chrono::Local>,
    /// Selected session index (if any)
    pub selected_index: Option<usize>,
    /// Account-level usage data from daemon (not Option)
    pub usage: &'a UsageData,
}

/// Trait that all dashboard widgets must implement
pub trait Widget: Send + Sync {
    /// Render the widget to a single line of styled text
    ///
    /// # Arguments
    /// * `width` - Available terminal width in columns
    /// * `context` - Shared context with session data and state
    ///
    /// # Returns
    /// A styled Line for Ratatui rendering
    fn render(&self, width: u16, context: &WidgetContext) -> Line<'_>;

    /// Widget identifier for configuration lookup
    fn id(&self) -> &'static str;

    /// Minimum width required for meaningful display
    ///
    /// Layout system may hide widget if terminal is narrower
    fn min_width(&self) -> u16;
}
```

### WidgetContext Details

`WidgetContext` is populated from daemon broadcasts (SUBSCRIBE messages) in the
TUI's event loop:

```rust
// TUI populates context from daemon data
let context = WidgetContext {
    sessions: &app.sessions,        // from daemon SessionUpdate
    usage: &app.usage,               // from daemon UsageUpdate
    now: chrono::Local::now(),       // local clock
    selected_index: app.selected_index,  // TUI internal state
};

// Widgets render using context
for widget in &active_layout.widgets {
    let line = widget.render(terminal_width, &context);
    // ... render line to terminal
}
```

### UsageData Type

```rust
pub struct UsageData {
    pub five_hour: QuotaWindow,
    pub seven_day: QuotaWindow,
    pub status: DataStatus,
}

pub struct QuotaWindow {
    pub utilization: f64,       // percentage (0-100)
    pub resets_at: DateTime<Utc>,
}

pub enum DataStatus {
    Ok,
    Unavailable,  // Fetch failed, widget shows placeholder
}
```

When `status` is `Unavailable`, widgets show graceful fallback (e.g., "Quota:
--").

> **Note:** Before the first daemon broadcast, `UsageData` defaults to
> `Unavailable`. Widgets must handle this state gracefully.

### Widget Registry Pattern

```rust
use std::collections::HashMap;

type WidgetFactory = fn() -> Box<dyn Widget>;

pub struct WidgetRegistry {
    factories: HashMap<&'static str, WidgetFactory>,
}

impl WidgetRegistry {
    pub fn new() -> Self {
        let mut registry = Self {
            factories: HashMap::new(),
        };

        // Register built-in widgets
        registry.register("session-status", || Box::new(SessionStatusWidget::new()));
        registry.register("working-dir", || Box::new(WorkingDirWidget::new()));
        registry.register("api-usage", || Box::new(ApiUsageWidget::new()));
        registry.register("state-history", || Box::new(StateHistoryWidget::new()));
        registry.register("clock", || Box::new(ClockWidget::new()));
        registry.register("spacer", || Box::new(SpacerWidget::new()));

        registry
    }

    pub fn register(&mut self, id: &'static str, factory: WidgetFactory) {
        self.factories.insert(id, factory);
    }

    pub fn create(&self, id: &str) -> Option<Box<dyn Widget>> {
        self.factories.get(id).map(|f| f())
    }
}
```

### Project Structure

```text
src/
├── widgets/
│   ├── mod.rs           # Widget trait, registry, re-exports
│   └── context.rs       # WidgetContext definition
```

### Widget Constraints (Architectural Rules)

Widgets MUST:

- Be stateless (no internal mutable state)
- Only read from `WidgetContext` parameter
- Never make external API calls
- Never directly access daemon socket
- Handle missing/unavailable data gracefully (show placeholder)

Widgets MUST NOT:

- Cache data between renders
- Call `claude_usage::get_usage()` directly (daemon fetches and broadcasts)
- Maintain timers or async tasks
- Depend on other widgets

See [widget data flow](../architecture/widget-data-flow.md) for rationale and
full architecture.

### Design Considerations

- Widgets are immutable after creation - all state comes from WidgetContext
- The `'_` lifetime in `Line<'_>` allows returning styled text without lifetime
  complications
- `Send + Sync` bound enables widgets to be stored in shared state across async
  tasks
- min_width allows graceful degradation on narrow terminals
- `&'a UsageData` (not `Option`) means TUI always provides usage data (may be
  status=Unavailable)

> **Note:** `UsageData` is defined in a shared types module (e.g.,
> `crates/shared/src/types.rs`) to avoid circular dependency between the widget
> crate (E005) and usage crate (E009). Both crates depend on the shared types
> crate.
